<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咸鱼的小站</title>
  
  
  <link href="https://blog.xianyu.one/atom.xml" rel="self"/>
  
  <link href="https://blog.xianyu.one/"/>
  <updated>2025-02-11T12:56:25.426Z</updated>
  <id>https://blog.xianyu.one/</id>
  
  <author>
    <name>咸鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我常用的那些golang与rust程序-EP01</title>
    <link href="https://blog.xianyu.one/2024/12/04/golang-rust-application-recommendations-ep01/"/>
    <id>https://blog.xianyu.one/2024/12/04/golang-rust-application-recommendations-ep01/</id>
    <published>2024-12-03T21:47:07.000Z</published>
    <updated>2025-02-11T12:56:25.426Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见！</p><p>由于工作过于繁忙以及游戏太好玩，鸽了大半年，今天老人作息，爬起来水一期</p><h2 id="为什么我热衷于使用golang及rust的程序"><a href="#为什么我热衷于使用golang及rust的程序" class="headerlink" title="为什么我热衷于使用golang及rust的程序"></a>为什么我热衷于使用golang及rust的程序</h2><p>作为一名主机、数据库运维工程师，日常会遇到很多奇奇怪怪的环境，例如就经常遇到RHEL6甚至RHEL5的上古平台，这时候想要使用一些现代化的工具就几乎不用想了，因为要编译、安装甚至构建编译环境都极其困难（因为多数客户的设备都不会连接互联网）。</p><p>此时golang及rust的优越性就体现出来了，以Golang为例，golang支持<code>2.6.23</code>及以上版本内核的任何Linux，也就是说RHEL6及以上的环境全部都能直接使用！直接把二进制包丢进去就可以了，属实过于方便。</p><h2 id="介绍一些好用的工具"><a href="#介绍一些好用的工具" class="headerlink" title="介绍一些好用的工具"></a>介绍一些好用的工具</h2><p>接下来就给大伙看看我平时常用的一些好东西</p><h3 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h3><h4 id="Caddy2"><a href="#Caddy2" class="headerlink" title="Caddy2"></a>Caddy2</h4><p><img src="https://pic.imgdb.cn/item/674f7fbed0e0a243d4dce59b.png"></p><ul><li><a href="https://github.com/caddyserver/caddy">项目地址</a></li></ul><p>一个非常好用的web服务器，🔒默认安全、支持HTTP3、支持自动签发续签SSL证书、强大的自定义功能以及丰富的插件！</p><p>另外也欢迎使用我的<a href="https://hub.docker.com/r/mrxianyu/caddy">客制化容器</a>！</p><h3 id="系统监控项"><a href="#系统监控项" class="headerlink" title="系统监控项"></a>系统监控项</h3><h4 id="gotop"><a href="#gotop" class="headerlink" title="gotop"></a>gotop</h4><p><img src="https://pic.imgdb.cn/item/674f80b6d0e0a243d4dce59f.png"></p><ul><li><a href="https://github.com/xxxserxxx/gotop">项目地址</a></li></ul><p>一个系统负载查看🇨🇭瑞士军刀</p><p>可以非常方便地查看cpu、内存、进程、磁盘等信息</p><p>一个小趣闻：原作者入了rust邪教跑去用rust重写了这个项目😆</p><h4 id="bottom"><a href="#bottom" class="headerlink" title="bottom"></a>bottom</h4><ul><li><p><a href="https://github.com/ClementTsang/bottom">项目地址</a></p></li><li><p><a href="https://github.com/ClementTsang/bottom">项目地址</a></p></li></ul><p>另一个系统负载查看🇨🇭瑞士军刀</p><p>可以非常方便地查看cpu、内存、进程、磁盘等信息</p><p>另一个小趣闻：就是上面👆那个gotop的作者写的</p><h4 id="bandwhich"><a href="#bandwhich" class="headerlink" title="bandwhich"></a>bandwhich</h4><p><img src="https://pic.imgdb.cn/item/674f8508d0e0a243d4dce5af.png"></p><ul><li><a href="https://github.com/imsnif/bandwhich">项目地址</a></li></ul><p>网络负载查看🇨🇭瑞士军刀</p><p>可以非常方便地查看网络负载</p><h4 id="kyanos"><a href="#kyanos" class="headerlink" title="kyanos"></a>kyanos</h4><p><img src="https://pic.imgdb.cn/item/674f8680d0e0a243d4dce5b9.png"></p><ul><li><a href="https://github.com/hengyoush/kyanos">项目地址</a></li></ul><p>使用ebpf黑科技的网络流量采集和分析工具</p><p>tql！</p><h4 id="gdu"><a href="#gdu" class="headerlink" title="gdu"></a>gdu</h4><p><img src="https://pic.imgdb.cn/item/674f8a13d0e0a243d4dce5c6.png"></p><ul><li><a href="https://github.com/dundee/gdu">项目地址</a></li></ul><p>磁盘占用分析工具</p><h3 id="网络安全工具"><a href="#网络安全工具" class="headerlink" title="网络安全工具"></a>网络安全工具</h3><h4 id="fscan"><a href="#fscan" class="headerlink" title="fscan"></a>fscan</h4><p><img src="https://pic.imgdb.cn/item/674f858dd0e0a243d4dce5b1.png"></p><ul><li><a href="https://github.com/shadow1ng/fscan">项目地址</a></li></ul><p>大名鼎鼎的fscan，网安小助手</p><p>一般我只用来扫描网段用</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="doggo"><a href="#doggo" class="headerlink" title="doggo"></a>doggo</h4><p><img src="https://pic.imgdb.cn/item/674f85fcd0e0a243d4dce5b2.png"></p><ul><li><a href="https://github.com/mr-karan/doggo">项目地址</a></li></ul><p>更加现代化的DNS命令行查询工具</p><p><del>由于dig用习惯了所以其实这个我用的挺少</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久不见！&lt;/p&gt;
&lt;p&gt;由于工作过于繁忙以及游戏太好玩，鸽了大半年，今天老人作息，爬起来水一期&lt;/p&gt;
&lt;h2 id=&quot;为什么我热衷于使用golang及rust的程序&quot;&gt;&lt;a href=&quot;#为什么我热衷于使用golang及rust的程序&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="推荐" scheme="https://blog.xianyu.one/tags/%E6%8E%A8%E8%8D%90/"/>
    
    <category term="分享" scheme="https://blog.xianyu.one/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="golang" scheme="https://blog.xianyu.one/tags/golang/"/>
    
    <category term="rust" scheme="https://blog.xianyu.one/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>AIX系统初体验</title>
    <link href="https://blog.xianyu.one/2024/05/06/AIX/welcome-AIX/"/>
    <id>https://blog.xianyu.one/2024/05/06/AIX/welcome-AIX/</id>
    <published>2024-05-06T01:40:12.000Z</published>
    <updated>2025-02-11T12:56:25.424Z</updated>
    
    <content type="html"><![CDATA[<p>由于未来工作中会接触AIX系统，所以想尝试熟悉一下这个来自IBM的神奇闭源类Unix系统</p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ul><li>一台使用Linux操作系统的计算机（其实其他系统也行）</li><li>完整的kvm虚拟化环境（如果没有，可以参考<a href="https://docs.xianyu.one/Linux%E7%9B%B8%E5%85%B3/%E8%99%9A%E6%8B%9F%E5%8C%96/%E5%AE%89%E8%A3%85KVM/">这篇文章</a>进行环境的安装）</li><li>AIX系统镜像，此处使用<a href="https://archive.org/details/aix_7200-04-02-2027_072020">AIX 7.2</a></li></ul><h3 id="安装qemu-system-ppc"><a href="#安装qemu-system-ppc" class="headerlink" title="安装qemu_system_ppc"></a>安装qemu_system_ppc</h3><p>由于KVM的安装并不会附带安装上不同架构的模拟软件，所以此处需要进行额外的安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">apt install qemu-system -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>等待安装完成后，我们的x86电脑就可以完整模拟包含<code>Power</code>架构在内的各类系统架构了</p><h2 id="正片"><a href="#正片" class="headerlink" title="正片"></a>正片</h2><p>接下来就进入正式的安装流程了</p><p>在本次实验中，所有的文件，例如虚拟磁盘、AIX的iso文件，都会放在当前目录下进行</p><h3 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h3><p>如同使用virt-manager创建虚拟机一样（虽然没有GUI，但又不是不能用）</p><p>需要为虚拟机创建一个虚拟磁盘</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">qemu-img create <span class="token parameter variable">-f</span> qcow2 aix.qcow2 100G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p>从<a href="https://archive.org/details/aix_7200-04-02-2027_072020">网络上</a>下载的AIX安装光盘镜像有两个镜像文件</p><ul><li><code>aix_7200-04-02-2027_1of2_072020.iso</code></li><li><code>aix_7200-04-02-2027_2of2_072020.iso</code></li></ul><p>实际在安装过程中仅需挂载第一个即可</p><p>下面是安装系统时的命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">qemu-system-ppc64 <span class="token punctuation">\</span><span class="token parameter variable">-cpu</span> POWER8 <span class="token punctuation">\</span><span class="token parameter variable">-machine</span> pseries <span class="token punctuation">\</span><span class="token parameter variable">-m</span> <span class="token number">8192</span> <span class="token punctuation">\</span><span class="token parameter variable">-serial</span> stdio <span class="token punctuation">\</span><span class="token parameter variable">-drive</span> <span class="token assign-left variable">file</span><span class="token operator">=</span>aix.qcow2,if<span class="token operator">=</span>none,id<span class="token operator">=</span>drive-virtio-disk0 <span class="token punctuation">\</span><span class="token parameter variable">-device</span> virtio-scsi-pci,id<span class="token operator">=</span>scsi <span class="token punctuation">\</span><span class="token parameter variable">-device</span> scsi-hd,drive<span class="token operator">=</span>drive-virtio-disk0 <span class="token punctuation">\</span><span class="token parameter variable">-cdrom</span> ./aix_7200-04-02-2027_1of2_072020.iso <span class="token punctuation">\</span>-prom-env <span class="token string">"boot-command=boot cdrom:"</span> <span class="token punctuation">\</span><span class="token parameter variable">-display</span> none<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>让我们先来逐行解读上面的命令：</p><ol><li><code>-cpu POWER8</code>: 指定虚拟机使用 POWER8 处理器。</li><li><code>-machine pseries</code>: 设置虚拟机的机器类型为 pseries。</li><li><code>-m 8192</code>: 设置虚拟机的内存为 8192 MB（8 GB）。</li><li><code>-serial stdio</code>: 将虚拟机的串行控制台重定向到标准输入&#x2F;输出。</li><li><code>-drive file=aix.qcow2,if=none,id=drive-virtio-disk0</code>: 创建一个虚拟磁盘驱动器，映射到名为 <code>aix.qcow2</code> 的 QCOW2 格式的磁盘文件。</li><li><code>-device virtio-scsi-pci,id=scsi</code>: 创建一个 Virtio SCSI 控制器，并指定其 ID 为 <code>scsi</code>。</li><li><code>-device scsi-hd,drive=drive-virtio-disk0</code>: 将之前创建的虚拟磁盘驱动器连接到 Virtio SCSI 控制器上。</li><li><code>-cdrom ./aix_7200-04-02-2027_1of2_072020.iso</code>: 将名为 <code>aix_7200-04-02-2027_1of2_072020.iso</code> 的 ISO 文件挂载为虚拟机的光驱。</li><li><code>-prom-env &quot;boot-command=boot cdrom:&quot;</code>: 设置 Open Firmware 环境变量，指定虚拟机启动时从光驱启动。</li><li><code>-display none</code>: 禁用图形显示，虚拟机将没有图形界面，所有操作通过命令行或串行控制台进行。</li></ol><p>运行后不出意外的话就正常跑起来了</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240506105245.webp"></p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>安装时会出现下图的情况</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240506105856.webp"><br>根据提示，我们扣1并回车</p><p>下一步会让我们选择语言，此处自然是直接回车默认使用英语安装 </p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240506110107.webp"></p><p>默认情况下AIX并不会主动安装上openssh，这里推荐先安装上，以便进入系统后的连接。这里我们输入<code>2</code>并回车</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240506110300.webp"></p><p>输入<code>4</code>查看更多选项</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507152419.webp"></p><p>这里可以看到我们到<code>OpenSSH Client</code>和<code>OpenSSH Server</code>均没有安装，此处分别输入<code>3</code>和<code>4</code>并回车即可将其更改为安装系统时附带将<code>OpenSSH Client</code>和<code>OpenSSH Server</code>一并安装上</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507152501.webp"></p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507152706.webp"></p><p>完成操作后输入<code>99</code>并回车两次，返回到最开始的安装界面</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240506110300.webp"></p><p>进入上图页面后直接回车两次开始安装</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507152929.webp"></p><p>接下去就是极其漫长的安装等待，<del>此处建议搓一把炉石</del></p><p>安装完成后会疯狂重启，此时使用ctrl+c退出，下面我们要为设备添加虚拟网卡（注意，此网卡是临时添加的，重启后会消失）</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">ip</span> tuntap <span class="token function">add</span> tap0 mode tap<span class="token function">sudo</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> tap0 up<span class="token function">sudo</span> <span class="token function">ip</span> a <span class="token function">add</span> <span class="token number">10.233</span>.11.1/24 dev tap0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>准备完成后就可以开始初始化系统了</p><h3 id="AIX，启动！"><a href="#AIX，启动！" class="headerlink" title="AIX，启动！"></a>AIX，启动！</h3><p>使用下面的命令启动AIX</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">qemu-system-ppc64 <span class="token punctuation">\</span><span class="token parameter variable">-cpu</span> POWER8 <span class="token punctuation">\</span><span class="token parameter variable">-machine</span> pseries <span class="token punctuation">\</span><span class="token parameter variable">-m</span> <span class="token number">8192</span> <span class="token punctuation">\</span><span class="token parameter variable">-serial</span> mon:stdio <span class="token punctuation">\</span><span class="token parameter variable">-drive</span> <span class="token assign-left variable">file</span><span class="token operator">=</span>aix.qcow2,if<span class="token operator">=</span>none,id<span class="token operator">=</span>drive-virtio-disk0 <span class="token punctuation">\</span><span class="token parameter variable">-device</span> virtio-scsi-pci,id<span class="token operator">=</span>scsi <span class="token punctuation">\</span><span class="token parameter variable">-device</span> scsi-hd,drive<span class="token operator">=</span>drive-virtio-disk0 <span class="token punctuation">\</span>-prom-env boot-command<span class="token operator">=</span><span class="token string">'boot disk:'</span> <span class="token punctuation">\</span><span class="token parameter variable">-display</span> none <span class="token punctuation">\</span><span class="token parameter variable">-net</span> nic <span class="token punctuation">\</span><span class="token parameter variable">-net</span> tap,script<span class="token operator">=</span>no,ifname<span class="token operator">=</span>tap0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>经过漫长的等待就进入系统初始化界面了</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507184008.webp"></p><p>此处输入vt100，接下去会跳是否接受许可，选中<code>Accept Licence Agreements</code>并回车</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507185132.webp"></p><p>此处有个大坑，我尝试了好久都没法把下图的<code>no</code>改成<code>yes</code>，既不是直接输入也不是用过左右键选择，而是使用<code>tab</code>键……</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507191749.webp"></p><p>回车后使用<code>f3</code>退出即可回到配置界面进行其他例如时区、密码的配置了</p><p>在此界面设置完毕后直接<code>f3</code>退出，可以进入Shell 界面</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507194554.webp"></p><h3 id="配置IP"><a href="#配置IP" class="headerlink" title="配置IP"></a>配置IP</h3><p>使用下面这个命令配置IP</p><figure><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chdev <span class="token parameter variable">-l</span> en0 <span class="token parameter variable">-a</span> <span class="token assign-left variable">netaddr</span><span class="token operator">=</span><span class="token number">10.233</span>.11.10 <span class="token parameter variable">-a</span> <span class="token assign-left variable">netmask</span><span class="token operator">=</span><span class="token number">255.255</span>.255.0 <span class="token parameter variable">-a</span> <span class="token assign-left variable">state</span><span class="token operator">=</span>up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>完成后就可以尝试ssh连接了</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507195836.webp"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>IBM的操作逻辑设计还是挺怪的，也可能是我不会用导致的，总之，慢慢来吧！</p><h3 id="为啥没有直接用virt-manager-创建"><a href="#为啥没有直接用virt-manager-创建" class="headerlink" title="为啥没有直接用virt-manager 创建"></a>为啥没有直接用virt-manager 创建</h3><p><a href="https://bugs.launchpad.net/ubuntu/+source/libvirt/+bug/1571075">https://bugs.launchpad.net/ubuntu/+source/libvirt/+bug/1571075</a></p><p>根据上面的内容可知遇到无法正常创建虚拟机的并非只有我一人，并且似乎并没有打算修的样子，命令行凑合用吧。</p><p><img src="/../../img/AIX/welcome-AIX/Pasted%20image%2020240507182915.webp"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://wzt.ac.cn/2021/05/28/QEMU-networking/">QEMU 网络配置一把梭</a></li><li><a href="https://kwakousys.wordpress.com/2020/09/06/run-aix-7-2-on-x86-with-qemu/">Run AIX 7.2 on x86 with QEMU</a></li><li><a href="https://community.unix.com/t/cannot-accept-license-agreement-on-smit-install/219089">Cannot Accept License Agreement on Smit Install?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于未来工作中会接触AIX系统，所以想尝试熟悉一下这个来自IBM的神奇闭源类Unix系统&lt;/p&gt;
&lt;h2 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准备&quot; class=&quot;headerlink&quot; title=&quot;前置准备&quot;&gt;&lt;/a&gt;前置准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一台使用</summary>
      
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="AIX" scheme="https://blog.xianyu.one/tags/AIX/"/>
    
    <category term="IBM" scheme="https://blog.xianyu.one/tags/IBM/"/>
    
  </entry>
  
  <entry>
    <title>subconverter进阶使用教学</title>
    <link href="https://blog.xianyu.one/2024/04/09/sub-server-re/"/>
    <id>https://blog.xianyu.one/2024/04/09/sub-server-re/</id>
    <published>2024-04-09T08:17:58.000Z</published>
    <updated>2025-02-11T12:56:25.426Z</updated>
    
    <content type="html"><![CDATA[<p>好久没水文章了，在wjh师傅的催更下来写一篇。</p><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>过去我曾写过一篇<a href="https://blog.xianyu.one/2021/05/12/Linux/tutorial/subconverter/">subconverter订阅转换及搭配 clash 使用教程</a></p><p>简要介绍了一下subconverter和clash的使用小技巧</p><p>本篇将要在原基础上更进一步，透过自定义的subconverter来获得更好的上网体验</p><h3 id="本文所解决的问题"><a href="#本文所解决的问题" class="headerlink" title="本文所解决的问题"></a>本文所解决的问题</h3><p>会想要做进一步的修改自然是因为实际使用遇到了一些问题：</p><ul><li>Clash存在DNS泄露</li><li>使用FakeIP后公司内网的DNS解析无法正常获取</li><li>国域网访问比蜗牛还慢</li></ul><p>实际上，为了方便大家使用，已经创建了一个<a href="https://github.com/xianyu-one/subconverter_configs">项目</a>来存放相关配置以及创建容器镜像来（如果可以请给我的项目加星 orz ）</p><h2 id="实际解决思路"><a href="#实际解决思路" class="headerlink" title="实际解决思路"></a>实际解决思路</h2><h3 id="解决DNS泄露问题"><a href="#解决DNS泄露问题" class="headerlink" title="解决DNS泄露问题"></a>解决DNS泄露问题</h3><p>首先就是修改外部配置文件了，在<a href="https://blog.xianyu.one/2021/05/12/Linux/tutorial/subconverter/">subconverter订阅转换及搭配 clash 使用教程</a>所介绍的配置目前已不太适用，请参考下面的配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">[custom];不要随意改变关键字，否则会导致出错;设置规则标志位ruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;LocalAreaNetwork.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;UnBan.listruleset&#x3D;🛑 全球拦截,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;BanAD.listruleset&#x3D;Google,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Google.listruleset&#x3D;Google,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;GoogleFCM.listruleset&#x3D;Google,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;GoogleCN.listruleset&#x3D;Google,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;GoogleCNProxyIP.listruleset&#x3D;📺 巴哈姆特,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Bahamut.listruleset&#x3D;📺 Youtube,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;YouTubeMusic.listruleset&#x3D;📺 Youtube,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;YouTube.listruleset&#x3D;🔰 节点选择,rules&#x2F;ConnersHua&#x2F;Surge&#x2F;Ruleset&#x2F;Global.listruleset&#x3D;🍎 苹果服务,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Apple.listruleset&#x3D;⚙️ 开发者,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Developer.listruleset&#x3D;⚙️ 开发者,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Github.listruleset&#x3D;Netflix,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Netflix.listruleset&#x3D;Netflix,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;NetflixIP.listruleset&#x3D;🔞 R18,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Porn.listruleset&#x3D;🖼️ Pixiv,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Pixiv.listruleset&#x3D;⚙️ 开发者,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Developer.listruleset&#x3D;⚙️ 开发者,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Github.listruleset&#x3D;Disney+,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;DisneyPlus.listruleset&#x3D;✈️ Telegram,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Telegram.listruleset&#x3D;🪟 巨硬服务,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Microsoft.listruleset&#x3D;🪟 巨硬服务,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;OneDrive.listruleset&#x3D;🎮 Xbox,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Xbox.listruleset&#x3D;🕹︎ Nintendo,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Nintendo.listruleset&#x3D;🖥️ PC游戏平台,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Epic.listruleset&#x3D;🖥️ PC游戏平台,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Steam.listruleset&#x3D;🖥️ PC游戏平台,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;Blizzard.listruleset&#x3D;🤖 AI相关,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Ruleset&#x2F;OpenAi.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;ChinaIpV6.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;Download.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;LocalAreaNetwork.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;UnBan.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;ChinaDomain.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;ChinaMedia.listruleset&#x3D;REJECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;BanAD.listruleset&#x3D;REJECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;BanProgramAD.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;ChinaCompanyIp.listruleset&#x3D;DIRECT,https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ACL4SSR&#x2F;ACL4SSR&#x2F;master&#x2F;Clash&#x2F;ChinaIp.listruleset&#x3D;DIRECT,[]GEOIP,CN,no-resolveruleset&#x3D;🐟 漏网之鱼,[]FINAL;设置规则标志位;设置分组标志位custom_proxy_group&#x3D;🔰 节点选择&#96;select&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]流媒体&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;✈ 手动选择&#96;select&#96;.*custom_proxy_group&#x3D;Disney+&#96;select&#96;[]🔰 节点选择&#96;[]🇹🇼 台湾地区&#96;[]🇸🇬 新加坡&#96;[]🇹🇼🇸🇬 中文地区&#96;[]流媒体&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;Google&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;📺 Youtube&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;⚙️ 开发者&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;🕹︎ Nintendo&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;🖥️ PC游戏平台&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;🎮 Xbox&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;🤖 AI相关&#96;select&#96;[]🔰 节点选择&#96;[]🇹🇼 台湾地区&#96;[]🇸🇬 新加坡&#96;[]🇹🇼🇸🇬 中文地区&#96;[]流媒体&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;🖼️ Pixiv&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;✈️ Telegram&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;📺 巴哈姆特&#96;select&#96;[]🇹🇼 台湾地区&#96;[]🔰 节点选择&#96;[]✈ 手动选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;(台)custom_proxy_group&#x3D;🍎 苹果服务&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;🪟 巨硬服务&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;🔞 R18&#96;select&#96;[]🔰 节点选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼🇸🇬 中文地区&#96;[]🇹🇼 台湾地区&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;Netflix&#96;select&#96;[]🔰 节点选择&#96;[]🇹🇼🇸🇬 中文地区&#96;[]流媒体&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]✈ 手动选择&#96;[]🌏 亚洲及大洋洲&#96;[]🌍 欧洲及中东地区&#96;[]🇺🇸🇨🇦 北美通用&#96;[]🇹🇼 台湾地区&#96;[]🇸🇬 新加坡&#96;[]🇯🇵 日本国&#96;[]🪙超低倍率0.2&#96;[]DIRECTcustom_proxy_group&#x3D;🌏 全球直连&#96;select&#96;[]DIRECT&#96;[]🔰 节点选择&#96;[]✈ 手动选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换custom_proxy_group&#x3D;🛑 全球拦截&#96;select&#96;[]REJECT&#96;[]DIRECTcustom_proxy_group&#x3D;🐟 漏网之鱼&#96;select&#96;[]🔰 节点选择&#96;[]✈ 手动选择&#96;[]✈ 延迟最低&#96;[]✈ 故障切换&#96;[]DIRECTcustom_proxy_group&#x3D;✈ 延迟最低&#96;url-test&#96;.*&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;✈ 故障切换&#96;fallback&#96;.*&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;🌏 亚洲及大洋洲&#96;url-test&#96;(台|新|日|韩|马来|印度|澳大利亚｜新西兰)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;🌍 欧洲及中东地区&#96;url-test&#96;(英|法|德|阿姆斯特丹|荷兰|土耳其|比利时|瑞士)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;🇺🇸🇨🇦 北美通用&#96;url-test&#96;(美|加拿)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;🇹🇼🇸🇬 中文地区&#96;url-test&#96;(台|新)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;🇹🇼 台湾地区&#96;url-test&#96;(台)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;🇯🇵 日本国&#96;url-test&#96;(日)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;🇸🇬 新加坡&#96;url-test&#96;(新加坡|R新|s新)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;流媒体&#96;url-test&#96;(R台|s台|R新|s新|流|流媒体)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500custom_proxy_group&#x3D;🪙超低倍率0.2&#96;url-test&#96;(0.2)&#96;http:&#x2F;&#x2F;www.gstatic.com&#x2F;generate_204&#96;500;设置分组标志位enable_rule_generator&#x3D;trueoverwrite_original_rules&#x3D;trueexclude_remarks&#x3D;(到期|官方|Traffic|Expire|剩余|时间|官网|产品|香港|俄罗斯)enable_rule_generator&#x3D;trueoverwrite_original_rules&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="添加redir-port配置"><a href="#添加redir-port配置" class="headerlink" title="添加redir-port配置"></a>添加redir-port配置</h3><p>redir-port是Linux 系统中iptables 的一个模块，它可以将来自特定来源IP 地址和端口的网络流量重定向到另一个目标IP 地址和端口。 这是一种防火墙规则，通常用于将内部网络中的流量重定向到特定的服务器或服务上，或者将流量从一个端口重定向到另一个端口</p><p>具体请看 <a href="https://github.com/xianyu-one/subconverter_configs/blob/main/subconverter_server_conf/pref.toml">项目地址</a></p><h3 id="为subconverter添加DNS部分的配置模板"><a href="#为subconverter添加DNS部分的配置模板" class="headerlink" title="为subconverter添加DNS部分的配置模板"></a>为subconverter添加DNS部分的配置模板</h3><p>由于subconverter默认转换时并不会附带DNS部分的配置，需要客户端进行添加，所以在这里我们直接通过修改subconverter的模板来实现向配置文件添加</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">dns:  enable: true  listen: 127.0.0.1:8853  default-nameserver:    - 223.5.5.5    - 8.8.4.4  ipv6: false  enhanced-mode: fake-ip  nameserver:    - 119.29.29.29    - 223.5.5.5    - tls:&#x2F;&#x2F;223.5.5.5:853    - tls:&#x2F;&#x2F;223.6.6.6:853    - tls:&#x2F;&#x2F;120.53.53.53    - tls:&#x2F;&#x2F;1.12.12.12  fallback:    - https:&#x2F;&#x2F;1.0.0.1&#x2F;dns-query    - https:&#x2F;&#x2F;public.dns.iij.jp&#x2F;dns-query    - tls:&#x2F;&#x2F;8.8.4.4:853  fallback-filter:    geoip: false    ipcidr:      - 240.0.0.0&#x2F;4      - 0.0.0.0&#x2F;32      - 127.0.0.1&#x2F;32    domain:      - +.facebook.com      - +.twitter.com      - +.google.com      - +.googleapis.com      - +.google.cn      - +.googleapis.cn      - +.xn--ngstr-lra8j.com      - +.googlevideo.com      - +.gvt1.com      - +.gmail.com      - +.youtube.com      - +.youtu.be      - +.gvt0.com      - +.gvt2.com      - +.gvt3.com      - +.gstatic.com      - +.265.com      - +.2mdn.net      - +.app-measurement.com      - +.c.admob.com      - +.clickserve.dartsearch.net      - +.crl.pki.goog      - +.doubleclick.net      - +.firebase-settings.crashlytics.com      - +.google-analytics.com      - +.googleadservices.com      - +.googleanalytics.com      - +.googleoptimize.com      - +.googlesyndication.com      - +.googletagmanager.com      - +.googletagservices.com  fake-ip-filter:    &#123;% include &quot;include&#x2F;cn-list.txt&quot; %&#125;    &#123;% include &quot;include&#x2F;a-list.txt&quot; %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>具体请看 <a href="https://github.com/xianyu-one/subconverter_configs/blob/main/subconverter_server_conf/pref.toml">项目地址</a></p><h4 id="fake-ip-filter"><a href="#fake-ip-filter" class="headerlink" title="fake-ip-filter"></a>fake-ip-filter</h4><p>fake-ip-filter<br>部分所添加的为国域网的域名清单，这边默认给的不多，<del>也就七万多条</del>，其作用是当DNS查询匹配这些域名时，并不会使用FakeIP，而是返回正确的解析，一方面这能提高国域网的访问速度，另一方面，你也可以通过添加自定义的内容（例如公司内网的域名）来获取真实的地址，防止开启代理的同时无法正常访问内网网站</p><p>如果你有自己的订阅转换服务器可以参考下面的方法进行自定义：</p><p>首先运行一个容器</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker run --name tester mrxianyu&#x2F;subconverter:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将容器内的<code>all_base.tpl</code>拷贝至本地的项容器目文件夹中（下面操作均是在本地的项容器目文件夹中进行的）</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker cp tester:&#x2F;base&#x2F;base&#x2F;all_base.tpl .&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将include文件夹拷贝出来</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker cp tester:&#x2F;base&#x2F;include .&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此处我们假设需要自定义的域名列表（格式参考include文件夹下已存在的文件）写在<code>include/URL.txt</code>中</p><p>接着我们向的<code>all_base.tpl</code>中的<code>fake-ip-filter</code>部分写入引用这个文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">..............      - +.firebase-settings.crashlytics.com      - +.google-analytics.com      - +.googleadservices.com      - +.googleanalytics.com      - +.googleoptimize.com      - +.googlesyndication.com      - +.googletagmanager.com      - +.googletagservices.com  fake-ip-filter:    &#123;% include &quot;include&#x2F;cn-list.txt&quot; %&#125;    &#123;% include &quot;include&#x2F;a-list.txt&quot; %&#125;    &#123;% include &quot;include&#x2F;URL.txt&quot; %&#125;.............<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最后使用如下示例dockercompose文件启用正式的订阅转换服务器即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">version: &#39;3&#39;services:  app:    image: mrxianyu&#x2F;subconverter    container_name: subconverter    restart: unless-stopped    volumes:      - .&#x2F;pref.toml:&#x2F;base&#x2F;pref.toml:ro      - .&#x2F;include:&#x2F;base&#x2F;include:ro    ports:      - &#39;25500:25500&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没水文章了，在wjh师傅的催更下来写一篇。&lt;/p&gt;
&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;过去我曾写过一篇&lt;a href=&quot;https://blog.x</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git设置代理</title>
    <link href="https://blog.xianyu.one/2023/11/30/git-proxy/"/>
    <id>https://blog.xianyu.one/2023/11/30/git-proxy/</id>
    <published>2023-11-30T00:17:54.000Z</published>
    <updated>2025-02-11T12:56:25.426Z</updated>
    
    <content type="html"><![CDATA[<p>由于众所周知的原因github的项目拉取和推送非常的痛苦，此篇以记录相关方法以拯救青年失智的我</p><span id="more"></span><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>确保已有<code>http</code>或<code>socks</code>代理，此处以<code>http://127.0.0.1:1080</code>和<code>socks5://127.0.0.1:1081</code>为例</p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>使用以下命令配置HTTP代理：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.proxy http://127.0.0.1:1080<span class="token function">git</span> config <span class="token parameter variable">--global</span> https.proxy http://127.0.0.1:1080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>使用以下命令配置SOCKS代理：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.proxy socks5://127.0.0.1:1081<span class="token function">git</span> config <span class="token parameter variable">--global</span> https.proxy socks5://127.0.0.1:1081<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="为特定目标进行设置"><a href="#为特定目标进行设置" class="headerlink" title="为特定目标进行设置"></a>为特定目标进行设置</h3><p>以为github设置为例</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.https://github.com.proxy socks5://127.0.0.1:1081<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于众所周知的原因github的项目拉取和推送非常的痛苦，此篇以记录相关方法以拯救青年失智的我&lt;/p&gt;</summary>
    
    
    
    
    <category term="教学" scheme="https://blog.xianyu.one/tags/%E6%95%99%E5%AD%A6/"/>
    
    <category term="git" scheme="https://blog.xianyu.one/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Docker Build 配置代理</title>
    <link href="https://blog.xianyu.one/2023/11/03/docker/docker-build-proxy/"/>
    <id>https://blog.xianyu.one/2023/11/03/docker/docker-build-proxy/</id>
    <published>2023-11-03T02:42:57.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<p>好像拖更有点久，我记得上一次写文章还是在上一次……</p><span id="more"></span><p>最近好多服务都开始用自己手搓的容器了，由于众所周知的原因，拉取很多项目的代码的体验会很差，在build阶段挂上代理就显得很重要了。</p><h2 id="设备及软件说明"><a href="#设备及软件说明" class="headerlink" title="设备及软件说明"></a>设备及软件说明</h2><p>本次演示使用的计算机操作系统为 <code>Ubuntu 22.04LTS</code> ，其他操作系统的方法基本一致。</p><p>软件方面有如下配置：</p><ul><li>Docker version 24.0.7</li><li>Docker Compose version v2.22.0</li><li>本机HTTP代理软件，默认监听本机的所以网卡的8080端口</li><li>ufw</li><li><a href="https://github.com/chaifeng/ufw-docker">ufw-docker</a> (一个用于解决docker导致ufw防火墙失效的小工具)</li></ul><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>本次实验以 <a href="https://caddyserver.com/v2">Caddy2</a> 的容器为例</p><h3 id="确认docker默认网卡的配置"><a href="#确认docker默认网卡的配置" class="headerlink" title="确认docker默认网卡的配置"></a>确认docker默认网卡的配置</h3><p>通常情况下Linux的Docker默认网卡名为 <code>docker0</code> ，默认IP及其网段信息一般情况下是 <code>172.17.0.1/16</code> ，在运行build命令时临时容器将会在这张网卡的网段下，所以需要明确这张网卡的配置信息，以方便后续配置本地HTTP代理的地址，以及如果你跟我一样开启了防火墙的情况下开放端口使用。</p><p>首先可以运行以下命令查看网卡信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ip</span> a show docker0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>你会得到类似如下的输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xianyu@book:/home/xianyu $ <span class="token function">ip</span> a show docker0<span class="token number">14</span>: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default     link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff    inet <span class="token number">172.17</span>.0.1/16 brd <span class="token number">172.17</span>.255.255 scope global docker0       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果你不打算修改默认配置的话就可以看下一节了，但如果你觉得默认网段有问题（不少企业网络会使用172的网段作为内网的地址段，会有比较大的概率冲突），那么就可以修改默认的网段。</p><h4 id="修改默认网段"><a href="#修改默认网段" class="headerlink" title="修改默认网段"></a>修改默认网段</h4><p>修改默认网段的方法非常简单，只需向 <code>/etc/docker/daemon.json</code> 中添加如下配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"bip"</span><span class="token operator">:</span><span class="token string">"10.233.0.1/24"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>并重启docker即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>同样的，重启后通过以下命令验证网段是否修改成功</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xianyu@book:/home/xianyu $ <span class="token function">ip</span> a show docker0<span class="token number">14</span>: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default     link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff    inet <span class="token number">10.233</span>.0.1/24 brd <span class="token number">10.233</span>.0.255 scope global docker0       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="开放防火墙端口"><a href="#开放防火墙端口" class="headerlink" title="开放防火墙端口"></a>开放防火墙端口</h3><p>由于目前IPv6的逐渐普及，计算机不开放防火墙会有极大的安全风险，所以在我的本地环境中是启用防火墙的</p><p>在上一节中我们提到了默认网卡的网段问题，此时我们可以知道默认网卡的网段为 <code>10.233.0.0/24</code> 本机作为网关在这个网段中的地址为 <code>10.233.0.1</code></p><p>我们希望这个网段中的容器可以访问本机的HTTP代理服务，即我们需要添加一条ufw规则以允许来自 <code>10.233.0.0/24</code> 的请求访问 <code>10.233.0.1:8080</code> ，具体的ufw命令如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw allow from <span class="token number">10.233</span>.0.0/24 to <span class="token number">10.233</span>.0.1 port <span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="编辑Dockerfile"><a href="#编辑Dockerfile" class="headerlink" title="编辑Dockerfile"></a>编辑Dockerfile</h3><p>做好上述准备我们就可以开始配置容器的HTTP代理了</p><p>本次实际案例为编译一个包含自定义插件的Caddy2容器，依照官方文档原始的Dockerfile长这样：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM caddy:builder AS builderRUN xcaddy build \    --with github.com&#x2F;caddy-dns&#x2F;cloudflareFROM caddyCOPY --from&#x3D;builder &#x2F;usr&#x2F;bin&#x2F;caddy &#x2F;usr&#x2F;bin&#x2F;caddy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到在 <code>RUN</code> 当中我们需要从Github拉取我们需要的代码，但实际上由于网络环境问题很难正常拉取到，此时我们可以在这里加入HTTP代理的变量使其拉取时走本机的代理</p><figure><div class="code-wrapper"><pre class="line-numbers language-Dockerfile" data-language="Dockerfile"><code class="language-Dockerfile">FROM caddy:builder AS builderENV http_proxy&#x3D;http:&#x2F;&#x2F;10.233.0.1:8080ENV https_proxy&#x3D;http:&#x2F;&#x2F;10.233.0.1:8080RUN xcaddy build \    --with github.com&#x2F;caddy-dns&#x2F;cloudflareFROM caddyCOPY --from&#x3D;builder &#x2F;usr&#x2F;bin&#x2F;caddy &#x2F;usr&#x2F;bin&#x2F;caddy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>经过上述处理即可愉快的手搓容器了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好像拖更有点久，我记得上一次写文章还是在上一次……&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="https://blog.xianyu.one/tags/docker/"/>
    
    <category term="proxy" scheme="https://blog.xianyu.one/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>kea DHCP 折腾小记</title>
    <link href="https://blog.xianyu.one/2023/06/01/Linux/tutorial/kea-dhcp/"/>
    <id>https://blog.xianyu.one/2023/06/01/Linux/tutorial/kea-dhcp/</id>
    <published>2023-06-01T12:39:13.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>别问，问就是在摆烂</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为<code>isc-dhcp</code>项目目前已不再更新，转向开发<code>kea DHCP</code>了，从官方的介绍中我们可以了解到<code>kea DHCP</code>有以下优点：</p><ul><li><p>灵活性：Kea DHCP 提供了广泛的配置选项和灵活的扩展机制，可以根据不同的网络需求进行高度定制。它支持动态更新配置、灵活的租约管理、多种地址分配策略以及丰富的选项定义。</p></li><li><p>性能和可扩展性：Kea DHCP 通过优化的设计和实现，具有出色的性能和可扩展性。它采用了多线程和异步处理，以处理大规模网络环境下的高并发请求，并能有效地管理大量的租约信息。</p></li><li><p>强大的管理和监控功能：Kea DHCP 提供了丰富的管理和监控功能，可通过命令行工具或REST API进行配置、状态查询和统计数据收集。管理员可以轻松地监视服务器状态、租约信息、日志记录，并进行动态配置和管理。</p></li><li><p>安全性：Kea DHCP 提供了安全的通信和认证机制，以保护服务器和客户端之间的通信安全。它支持TLS加密和身份验证，可以防止未经授权的访问和数据泄露。</p></li><li><p>兼容性：Kea DHCP 兼容标准的DHCPv4和DHCPv6协议，并支持常见的客户端操作系统和网络设备。它还支持动态DNS（DDNS）更新、网站指导模式（Captive Portal）、PXE引导、客户端分类和挂钩脚本等功能。</p></li></ul><p>注意，这是官方说法，我也信了，但最后为什么选择不迁移了呢？且听我娓娓道来</p><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>这次测试使用的环境是在KVM虚拟化的环境中进行的，使用<code>172.18.146.0/24</code>作为测试网段<br><img src="https://pic.imgdb.cn/item/647be21bf024cca173f0dca9.jpg"></p><p>DHCP服务器将架设在一台运行<code>UbuntuServer 22.04.2 LTS</code>的虚拟机上，仅启用DHCPv4（v6用不上），此外是直接用root用户操作的（我懒得打sudo）</p><table><thead><tr><th>设备</th><th>IP</th><th>操作系统</th></tr></thead><tbody><tr><td>DHCP Server</td><td>172.18.146.53</td><td>UbuntuServer 22.04.2 LTS</td></tr><tr><td>User</td><td>DHCPv4</td><td>Windows 10 Pro</td></tr></tbody></table><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>安装<code>kea</code>可以直接使用<code>apt</code>进行安装，也可以编译安装，这里我们两者都会介绍到。</p><h3 id="软件源安装"><a href="#软件源安装" class="headerlink" title="软件源安装"></a>软件源安装</h3><p>这种方法非常简单，一条命令即可完成安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt</span> <span class="token function">install</span> kea<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>上述命令将会自动安装kea在软件源中的所有软件（但不是所有其项目的所有软件，后面会说）</p><p>以下是源中所有可选安装的组件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kea                   kea-ctrl-agent        kea-dhcp4-serverkea-admin             kea-dev               kea-dhcp6-serverkea-common            kea-dhcp-ddns-server  kea-doc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>在本次实验中，使用下面的命令安装部分必要的组件即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt</span> <span class="token function">install</span> kea-ctrl-agent kea-dhcp4-server kea-admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>安装好后配置文件均位于<code>/etc/kea</code>文件夹中</p><h4 id="为什么不推荐源安装"><a href="#为什么不推荐源安装" class="headerlink" title="为什么不推荐源安装"></a>为什么不推荐源安装</h4><p>源中的软件包缺失了很多<code>kea</code>所推荐或是新增的功能，例如源安装的<code>kea</code>并不能正常的与数据库进行交互（似乎是源预编译没有使用相关选项进行编译），同时缺失了hooks的支持，在版本上，也比官方的落后一些（目前ubuntu源的kea组件是2.0.2版本的）</p><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>源码安装的好处是可以用上kea的所有功能，缺点是需要忍受很长的编译时间。<br>本次实验环境所编译的包为构建用于和mysql（也可以是mariadb）交互的。</p><h4 id="安装编译所需包"><a href="#安装编译所需包" class="headerlink" title="安装编译所需包"></a>安装编译所需包</h4><p>首先根据官方文档所要求的安装编译所需的软件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> <span class="token function">curl</span> libboost-all-dev openssl <span class="token function">git</span> g++ libssl-dev liblog4cplus-dev liblog4cplus-2.0.5 <span class="token function">make</span> cmake <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>由于需要在编译时加上<code>--with-mysql</code>的选项，所以需要额外安装以下的包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> mysql-client libmysqlclient-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="拉取源码"><a href="#拉取源码" class="headerlink" title="拉取源码"></a>拉取源码</h4><p>直接从官方仓库拉取即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://gitlab.isc.org/isc-projects/kea.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="编译并安装软件"><a href="#编译并安装软件" class="headerlink" title="编译并安装软件"></a>编译并安装软件</h4><h5 id="进入项目文件夹"><a href="#进入项目文件夹" class="headerlink" title="进入项目文件夹"></a>进入项目文件夹</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> kea/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">autoreconf <span class="token parameter variable">-i</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="生成构建环境"><a href="#生成构建环境" class="headerlink" title="生成构建环境"></a>生成构建环境</h5><p>由于我们需要使用mysql数据库，所以此处需要加上–with-mysql&#96;的选项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --with-mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="编译软件"><a href="#编译软件" class="headerlink" title="编译软件"></a>编译软件</h5><p>通常情况下会花费很多时间，可以先出门吃个饭</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h5 id="更新链接缓存"><a href="#更新链接缓存" class="headerlink" title="更新链接缓存"></a>更新链接缓存</h5><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/libldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>依照上述方法编译后配置文件夹默认位置为软件安装位置下的<code>etc/kea</code>子文件夹中</p><h2 id="正式使用及配置文件解析"><a href="#正式使用及配置文件解析" class="headerlink" title="正式使用及配置文件解析"></a>正式使用及配置文件解析</h2><p>完成上一节操作后就可以正式开始使用kea了，但是！这里就要说一说kea不好的地方了，kea的配置文件，是json的格式，这意味着，会有一大堆的括号，极不利于阅读</p><h3 id="简易使用教学"><a href="#简易使用教学" class="headerlink" title="简易使用教学"></a>简易使用教学</h3><p>kea可以通过<code>keactrl</code>来启用各项服务（其实systemctl也可以用，如果是从源码编译的systemctl命令不能开箱即用），例如可以使用以下命令查看服务状态</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@testserver:/home/app/kea<span class="token comment"># keactrl status</span>DHCPv4 server: activeDHCPv6 server: activeDHCP DDNS: activeControl Agent: activeKea DHCPv4 configuration file: /etc/kea/kea-dhcp4.confKea DHCPv6 configuration file: /etc/kea/kea-dhcp6.confKea DHCP DDNS configuration file: /etc/kea/kea-dhcp-ddns.confKea Control Agent configuration file: /etc/kea/kea-ctrl-agent.confkeactrl configuration file: /etc/kea/keactrl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到各项服务都启动了</p><p>在不添加选项的情况下，<code>keactrl start</code>将会根据配置文件夹下的<code>keactrl.conf</code>配置文件的内容来启动相关服务，例如我们不想启动DHCPv6的服务的话就可以将配置文件中的</p><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config"># Start DHCPv6 server?dhcp6&#x3D;yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>改成</p><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config"># Start DHCPv6 server?dhcp6&#x3D;no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h3><p>此处我们以DHCPv4来说（别的我也不想用）,下面是一个配置文件的节选（不用仔细看，我会将其拆分的更仔细，仅注意我所添加的分割线即可）</p><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config">&quot;Dhcp4&quot;: &#123;    &quot;interfaces-config&quot;: &#123;        &quot;interfaces&quot;: [ ]    &#125;,&#x2F;&#x2F; ################################ 此处分割 #######################################    &quot;control-socket&quot;: &#123;        &quot;socket-type&quot;: &quot;unix&quot;,        &quot;socket-name&quot;: &quot;&#x2F;tmp&#x2F;kea4-ctrl-socket&quot;    &#125;,&#x2F;&#x2F; ################################ 此处分割 #######################################    &quot;lease-database&quot;: &#123;        &#x2F;&#x2F; Memfile is the simplest and easiest backend to use. It&#39;s an in-memory        &#x2F;&#x2F; C++ database that stores its state in CSV file.        &quot;type&quot;: &quot;memfile&quot;,        &quot;lfc-interval&quot;: 3600    &#125;,    &quot;hosts-database&quot;: &#123;        &quot;type&quot;: &quot;mysql&quot;,        &quot;name&quot;: &quot;kea&quot;,        &quot;user&quot;: &quot;kea&quot;,        &quot;password&quot;: &quot;kea&quot;,        &quot;host&quot;: &quot;localhost&quot;,        &quot;port&quot;: 3306    &#125;,&#x2F;&#x2F; ################################ 此处分割 #######################################    &quot;expired-leases-processing&quot;: &#123;        &quot;reclaim-timer-wait-time&quot;: 10,        &quot;flush-reclaimed-timer-wait-time&quot;: 25,        &quot;hold-reclaimed-time&quot;: 3600,        &quot;max-reclaim-leases&quot;: 100,        &quot;max-reclaim-time&quot;: 250,        &quot;unwarned-reclaim-cycles&quot;: 5    &#125;,    &quot;renew-timer&quot;: 900,    &quot;rebind-timer&quot;: 1800,    &quot;valid-lifetime&quot;: 3600,    &quot;option-data&quot;: [        &#123;            &quot;name&quot;: &quot;domain-name-servers&quot;,            &quot;data&quot;: &quot;192.0.2.1, 192.0.2.2&quot;        &#125;,        &#123;            &quot;code&quot;: 15,            &quot;data&quot;: &quot;example.org&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;domain-search&quot;,            &quot;data&quot;: &quot;mydomain.example.com, example.com&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;boot-file-name&quot;,            &quot;data&quot;: &quot;EST5EDT4\\,M3.2.0&#x2F;02:00\\,M11.1.0&#x2F;02:00&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;default-ip-ttl&quot;,            &quot;data&quot;: &quot;0xf0&quot;        &#125;    ],&#x2F;&#x2F; ################################ 此处分割 #######################################    &quot;client-classes&quot;: [        &#123;            &quot;name&quot;: &quot;voip&quot;,            &quot;test&quot;: &quot;substring(option[60].hex,0,6) &#x3D;&#x3D; &#39;Aastra&#39;&quot;,            &quot;next-server&quot;: &quot;192.0.2.254&quot;,            &quot;server-hostname&quot;: &quot;hal9000&quot;,            &quot;boot-file-name&quot;: &quot;&#x2F;dev&#x2F;null&quot;        &#125;    ],&#x2F;&#x2F; ################################ 此处分割 #######################################    &#x2F;&#x2F; &quot;hooks-libraries&quot;: [    &#x2F;&#x2F;   &#123;    &#x2F;&#x2F;       &#x2F;&#x2F; Forensic Logging library generates forensic type of audit trail    &#x2F;&#x2F;       &#x2F;&#x2F; of all devices serviced by Kea, including their identifiers    &#x2F;&#x2F;       &#x2F;&#x2F; (like MAC address), their location in the network, times    &#x2F;&#x2F;       &#x2F;&#x2F; when they were active etc.    &#x2F;&#x2F;       &quot;library&quot;: &quot;&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;kea&#x2F;hooks&#x2F;libdhcp_legal_log.so&quot;,    &#x2F;&#x2F;       &quot;parameters&quot;: &#123;    &#x2F;&#x2F;           &quot;path&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;kea&quot;,    &#x2F;&#x2F;           &quot;base-name&quot;: &quot;kea-forensic4&quot;    &#x2F;&#x2F;       &#125;    &#x2F;&#x2F;   &#125;,    &#x2F;&#x2F;   &#123;    &#x2F;&#x2F;       &#x2F;&#x2F; Flexible identifier (flex-id). Kea software provides a way to    &#x2F;&#x2F;       &#x2F;&#x2F; handle host reservations that include addresses, prefixes,    &#x2F;&#x2F;       &#x2F;&#x2F; options, client classes and other features. The reservation can    &#x2F;&#x2F;       &#x2F;&#x2F; be based on hardware address, DUID, circuit-id or client-id in    &#x2F;&#x2F;       &#x2F;&#x2F; DHCPv4 and using hardware address or DUID in DHCPv6. However,    &#x2F;&#x2F;       &#x2F;&#x2F; there are sometimes scenario where the reservation is more    &#x2F;&#x2F;       &#x2F;&#x2F; complex, e.g. uses other options that mentioned above, uses part    &#x2F;&#x2F;       &#x2F;&#x2F; of specific options or perhaps even a combination of several    &#x2F;&#x2F;       &#x2F;&#x2F; options and fields to uniquely identify a client. Those scenarios    &#x2F;&#x2F;       &#x2F;&#x2F; are addressed by the Flexible Identifiers hook application.    &#x2F;&#x2F;       &quot;library&quot;: &quot;&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;kea&#x2F;hooks&#x2F;libdhcp_flex_id.so&quot;,    &#x2F;&#x2F;       &quot;parameters&quot;: &#123;    &#x2F;&#x2F;           &quot;identifier-expression&quot;: &quot;relay4[2].hex&quot;    &#x2F;&#x2F;       &#125;    &#x2F;&#x2F;   &#125;    &#x2F;&#x2F; ],&#x2F;&#x2F; ################################ 此处分割 #######################################    &quot;subnet4&quot;: [        &#123;            &quot;subnet&quot;: &quot;192.0.2.0&#x2F;24&quot;,            &quot;pools&quot;: [ &#123; &quot;pool&quot;: &quot;192.0.2.1 - 192.0.2.200&quot; &#125; ],            &quot;option-data&quot;: [                &#123;                    &quot;name&quot;: &quot;routers&quot;,                    &quot;data&quot;: &quot;192.0.2.1&quot;                &#125;            ],            &quot;reservations&quot;: [                &#123;                    &quot;hw-address&quot;: &quot;1a:1b:1c:1d:1e:1f&quot;,                    &quot;ip-address&quot;: &quot;192.0.2.201&quot;                &#125;            ]        &#125;    ],&#x2F;&#x2F; ################################ 此处分割 #######################################    &quot;loggers&quot;: [    &#123;        &quot;name&quot;: &quot;kea-dhcp4&quot;,        &quot;output_options&quot;: [            &#123;                &#x2F;&#x2F; Specifies the output file. There are several special values                &#x2F;&#x2F; supported:                &#x2F;&#x2F; - stdout (prints on standard output)                &#x2F;&#x2F; - stderr (prints on standard error)                &#x2F;&#x2F; - syslog (logs to syslog)                &#x2F;&#x2F; - syslog:name (logs to syslog using specified name)                &#x2F;&#x2F; Any other value is considered a name of the file                &quot;output&quot;: &quot;&#x2F;var&#x2F;log&#x2F;kea-dhcp4.log&quot;                &#x2F;&#x2F; Shorter log pattern suitable for use with systemd,                &#x2F;&#x2F; avoids redundant information                &#x2F;&#x2F; &quot;pattern&quot;: &quot;%-5p %m\n&quot;                &#x2F;&#x2F; This governs whether the log output is flushed to disk after                &#x2F;&#x2F; every write.                &#x2F;&#x2F; &quot;flush&quot;: false,                &#x2F;&#x2F; This specifies the maximum size of the file before it is                &#x2F;&#x2F; rotated.                &#x2F;&#x2F; &quot;maxsize&quot;: 1048576,                &#x2F;&#x2F; This specifies the maximum number of rotated files to keep.                &#x2F;&#x2F; &quot;maxver&quot;: 8            &#125;        ],        &quot;severity&quot;: &quot;INFO&quot;,        &quot;debuglevel&quot;: 0    &#125;  ]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="监听网卡配置"><a href="#监听网卡配置" class="headerlink" title="监听网卡配置"></a>监听网卡配置</h4><p>配置文件中的<code>interfaces-config</code>配置用于告诉软件应该监听什么端口，例如我们的网口为<code>eth0</code>，就应该将此项配置的<code>&quot;interfaces&quot;: [ ]</code>改为如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config">&quot;interfaces&quot;: [ &#39;eth0&#39; ]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h4><p>数据库配置有两种，一种为以本地文件为数据库的形式，即下面这段</p><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config">&quot;lease-database&quot;: &#123;    &#x2F;&#x2F; Memfile is the simplest and easiest backend to use. It&#39;s an in-memory    &#x2F;&#x2F; C++ database that stores its state in CSV file.    &quot;type&quot;: &quot;memfile&quot;,    &quot;lfc-interval&quot;: 3600&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>还有一种是真数据库，即下面这段</p><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config">&quot;hosts-database&quot;: &#123;    &quot;type&quot;: &quot;mysql&quot;,    &quot;name&quot;: &quot;kea&quot;,    &quot;user&quot;: &quot;kea&quot;,    &quot;password&quot;: &quot;kea&quot;,    &quot;host&quot;: &quot;localhost&quot;,    &quot;port&quot;: 3306&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以根据自己的实际情况选择使用哪一种</p><h4 id="全局的DHCP配置"><a href="#全局的DHCP配置" class="headerlink" title="全局的DHCP配置"></a>全局的DHCP配置</h4><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config">&quot;expired-leases-processing&quot;: &#123;    .......&#125;,&quot;renew-timer&quot;: 900,&quot;rebind-timer&quot;: 1800,&quot;valid-lifetime&quot;: 3600,&quot;option-data&quot;: [    .......],<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>上面这段为全局下的dhcp配置</p><ul><li><code>renew-timer</code>表示客户端在租约过期前需要发起续租（Renew）请求的时间间隔。在默认配置中，客户端应在租约过期前的<strong>几秒</strong>内发送续租请求。如果客户端成功续租，则租约会得到更新，继续使用同一IP地址</li><li><code>rebind-timer</code>表示在租约过期后，如果客户端无法与原DHCP服务器通信，客户端可以向任意可用的DHCP服务器发送绑定（Rebind）请求的时间间隔。在默认配置中，客户端可以在租约过期后的<strong>几秒</strong>内发送绑定请求，以尝试绑定到任意可用的DHCP服务器并获取新的租约</li><li><code>valid-lifetime</code>表示租约的有效期，即客户端可以使用分配的IP地址的时间长度。在默认配置中，客户端获得的租约将在<strong>几秒</strong>后过期，除非在此期间成功进行了续租。</li></ul><p><code>option-data</code>中所填入的为RFC2132定义的DHCP的各类功能相关的配置，基本格式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config">&#123;    &quot;code&quot;: 15,    &quot;data&quot;: &quot;example.org&quot;&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>上面这段代码的含义是定义了DHCP服务器的域名（Domain Name，DHCP代码为15），下面是部分的DHCP代码表提供参考</p><table><thead><tr><th>DHCP代码</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>子网掩码（Subnet Mask）</td></tr><tr><td>2</td><td>时间偏移（Time Offset）</td></tr><tr><td>3</td><td>默认网关（Router）</td></tr><tr><td>4</td><td>时间服务器（Time Server）</td></tr><tr><td>5</td><td>名称服务器（Name Server）</td></tr><tr><td>6</td><td>DNS服务器（Domain Name Server）</td></tr><tr><td>7</td><td>日志服务器（Log Server）</td></tr><tr><td>8</td><td>Cookie服务器（Cookie Server）</td></tr><tr><td>9</td><td>LPR服务器（Line Printer Server）</td></tr><tr><td>12</td><td>主机名（Host Name）</td></tr><tr><td>15</td><td>域名（Domain Name）</td></tr><tr><td>17</td><td>根路径（Root Path）</td></tr><tr><td>18</td><td>扩展路径（Extensions Path）</td></tr><tr><td>19</td><td>IP层最大数据长度（IP Layer Maximum Datagram Size）</td></tr><tr><td>23</td><td>默认IP生存时间（Default IP Time-to-Live）</td></tr><tr><td>28</td><td>广播地址（Broadcast Address）</td></tr><tr><td>33</td><td>静态路由（Static Route）</td></tr><tr><td>43</td><td>供应商特定选项（Vendor Specific Information）</td></tr><tr><td>50</td><td>请求的IP地址（Requested IP Address）</td></tr><tr><td>51</td><td>租约时间（IP Address Lease Time）</td></tr><tr><td>53</td><td>DHCP消息类型（DHCP Message Type）</td></tr><tr><td>54</td><td>服务器标识（Server Identifier）</td></tr><tr><td>55</td><td>参数请求列表（Parameter Request List）</td></tr><tr><td>56</td><td>DHCP消息（Message）</td></tr><tr><td>57</td><td>最大DHCP消息大小（Maximum DHCP Message Size）</td></tr><tr><td>58</td><td>客户端唯一标识（Client Identifier）</td></tr><tr><td>59</td><td>客户端状态（Client System）</td></tr><tr><td>60</td><td>厂商类标识（Vendor class identifier）</td></tr><tr><td>61</td><td>客户机硬件地址（Client Identifier）</td></tr><tr><td>66</td><td>TFTP服务器名称（TFTP Server Name）</td></tr><tr><td>67</td><td>引导文件名称（Bootfile Name）</td></tr><tr><td>69</td><td>炸弹选项（DHCP Relay Agent Information）</td></tr><tr><td>150</td><td>TFTP服务器地址（TFTP Server Address）</td></tr></tbody></table><p>需要注意，这是标准的DHCP协议的定义，虽然kea的软件是遵照标准所设计的，但在实际填写各选项时，请务必还是看一眼kea的<a href="https://kea.readthedocs.io/en/kea-2.0.2/arm/dhcp4-srv.html#standard-dhcpv4-options">官方文档</a>，确定配置应如何编写</p><h4 id="kea扩展"><a href="#kea扩展" class="headerlink" title="kea扩展"></a>kea扩展</h4><p>在配置文件中为<code>hooks-libraries</code>段落，此为kea的高级应用，不说了（我懒）</p><h4 id="地址池配置"><a href="#地址池配置" class="headerlink" title="地址池配置"></a>地址池配置</h4><p>地址池配置为<code>subnet4</code>段落，下面是定义一个网段的配置</p><figure><div class="code-wrapper"><pre class="line-numbers language-config" data-language="config"><code class="language-config">&#123;            &quot;subnet&quot;: &quot;192.0.2.0&#x2F;24&quot;,            &quot;pools&quot;: [ &#123; &quot;pool&quot;: &quot;192.0.2.1 - 192.0.2.200&quot; &#125; ],            &quot;option-data&quot;: [                &#123;                    &quot;name&quot;: &quot;routers&quot;,                    &quot;data&quot;: &quot;192.0.2.1&quot;                &#125;            ],            &quot;reservations&quot;: [                &#123;                    &quot;hw-address&quot;: &quot;1a:1b:1c:1d:1e:1f&quot;,                    &quot;ip-address&quot;: &quot;192.0.2.201&quot;                &#125;            ]        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>subnet: 定义一个子网，此处为 <code>192.0.2.0/24</code>，表示一个以 <code>192.0.2.0</code> 作为网络地址的CIDR形式的子网，子网掩码为<code>255.255.255.0</code>。</li><li>pools: 定义了一个地址池，其中包含一个范围。此处的地址池为 “192.0.2.1 - 192.0.2.200”，表示可用于分配的IP地址范围从<code>192.0.2.1</code>到<code>192.0.2.200</code>。</li><li>option-data: 定义了DHCP选项的数据。在这里，指定了一个名为 “routers” 的选项，其值为 <code>192.0.2.1</code>。这表示在DHCP租约期间，客户端将收到一个名为 “routers” 的选项，并且该选项的值将设置为 “192.0.2.1”，指示客户端使用该IP地址作为默认网关。这个定义仅适用于此地址池，且其优先级高于全局的option-data。</li><li>reservations: 定义了一个预留（reservation），用于为特定的客户端设备分配特定的IP地址。在此配置中，指定了一个硬件地址（hw-address）为 <code>1a:1b:1c:1d:1e:1f</code> 的设备，将被分配IP地址 <code>192.0.2.201</code>。</li></ul><h2 id="为什么最后又不选择使用kea-DHCP？"><a href="#为什么最后又不选择使用kea-DHCP？" class="headerlink" title="为什么最后又不选择使用kea DHCP？"></a>为什么最后又不选择使用kea DHCP？</h2><ul><li><p>kea DHCP的模块化确实为部署提供了很多的选择，但这个模块化并不人性，并不是通过添加或删除可执行文件就可以增加或减少其功能的，而是需要进行编译。</p></li><li><p>stork为kea官方所推荐使用的监控平台，但功能过于鸡肋。</p></li><li><p>数据库方面没有很成熟的方式进行操作，交互上需要通过hook，并且如果要方便管理员使用则需要二次开发</p></li><li><p>json格式的配置文件过于反人类，看的眼睛疼</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;别问，问就是在摆烂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;因为&lt;code&gt;isc-dhcp&lt;/</summary>
      
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://blog.xianyu.one/tags/Linux/"/>
    
    <category term="DHCP" scheme="https://blog.xianyu.one/tags/DHCP/"/>
    
  </entry>
  
  <entry>
    <title>Openwrt使用wireguard实现异地组网</title>
    <link href="https://blog.xianyu.one/2023/02/08/wireguard-connect/"/>
    <id>https://blog.xianyu.one/2023/02/08/wireguard-connect/</id>
    <published>2023-02-08T15:03:29.000Z</published>
    <updated>2025-02-11T12:56:25.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>失踪几个月终于更新了</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>事情是这样的，早在2022年我换上了Pixe之后惊奇的发现android13默默移除了L2TP的支持，只能使用IPsec的VPN了，对于我这样的懒狗来说，配置IPsec是不可能的，这辈子都是不可能的</p><p>所以！我换掉了原先家中使用的某品牌成品AC，改用支持<code>wireguard</code>的Openwrt开发板来作为主路由使用。并开始了这一次的折腾</p><span id="more"></span><h2 id="设备及环境介绍"><a href="#设备及环境介绍" class="headerlink" title="设备及环境介绍"></a>设备及环境介绍</h2><p>在实作过程中，踩了不少坑，并且由于openwrt版本不同的情况下软件包会有一点区别，所以在此标注本次实操的系统版本等信息，<strong>需要注意：请保证两端LAN的网段不能有重合！</strong></p><table><thead><tr><th align="center">设备</th><th align="center">A地路由（拥有ipv4公网IP）</th><th align="center">B地路由（无ipv4公网IP）</th></tr></thead><tbody><tr><td align="center">系统版本</td><td align="center">openwrt-22.03</td><td align="center">openwrt-22.03</td></tr><tr><td align="center">LAN口IP</td><td align="center">192.168.10.1&#x2F;24</td><td align="center">192.168.20.1&#x2F;24</td></tr><tr><td align="center">wg网段IP</td><td align="center">10.0.0.1&#x2F;24</td><td align="center">10.0.0.2&#x2F;24</td></tr></tbody></table><h2 id="A地路由设置"><a href="#A地路由设置" class="headerlink" title="A地路由设置"></a>A地路由设置</h2><h3 id="添加防火墙"><a href="#添加防火墙" class="headerlink" title="添加防火墙"></a>添加防火墙</h3><p>首先需要添加一个<code>wireguard</code>的防火墙区域，依照下图设置即可</p><p><img src="https://pic.imgdb.cn/item/63e35bee4757feff331f20e7.jpg"></p><h3 id="添加wireguard虚拟接口"><a href="#添加wireguard虚拟接口" class="headerlink" title="添加wireguard虚拟接口"></a>添加wireguard虚拟接口</h3><p>在 <code>网络</code>-<code>接口</code> 页面新建一个接口，名字随意并选择协议为<code>Wireguard VPN</code></p><p><img src="https://pic.imgdb.cn/item/63e35ca54757feff33206d07.jpg"></p><h3 id="虚拟接口配置"><a href="#虚拟接口配置" class="headerlink" title="虚拟接口配置"></a>虚拟接口配置</h3><p>点击<code>生成新的密钥对</code>生成本机的公钥和私钥，并填写下方监听端口我们规划好的此设备在wireguard虚拟网络中的ip</p><p><img src="https://pic.imgdb.cn/item/63e35dec4757feff3322a2bb.jpg"></p><p>记得配置此接口所在的防火墙区域</p><p><img src="https://pic.imgdb.cn/item/63e35e1e4757feff3322f9de.jpg"></p><p>到这里，我们就可以暂时保存端口的设置了，等B设备配置好后我们再回来配置对端设置。（其实此处可以先在这台路由上将B端的公私钥生成好并填写对端配置）</p><h3 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h3><p>为了让局域网下的设备访问到对端网段下的设备，最好请添加以下静态路由（实测好像不加也没事）</p><p><img src="https://pic.imgdb.cn/item/63e35f024757feff3324aa94.jpg"></p><p>上图中的含义为：当接口区域<code>wg</code>有去往<code>192.168.20.0/24</code>网段的数据包时，将其网关设为本机在<code>wireguard</code>虚拟网络中的ip地址</p><h2 id="B地路由设置"><a href="#B地路由设置" class="headerlink" title="B地路由设置"></a>B地路由设置</h2><h3 id="添加防火墙-1"><a href="#添加防火墙-1" class="headerlink" title="添加防火墙"></a>添加防火墙</h3><p>首先需要添加一个<code>wireguard</code>的防火墙区域，依照下图设置即可</p><p><img src="https://pic.imgdb.cn/item/63e35bee4757feff331f20e7.jpg"></p><h3 id="添加wireguard虚拟接口-1"><a href="#添加wireguard虚拟接口-1" class="headerlink" title="添加wireguard虚拟接口"></a>添加wireguard虚拟接口</h3><p>在 <code>网络</code>-<code>接口</code> 页面新建一个接口，名字随意并选择协议为<code>Wireguard VPN</code></p><p><img src="https://pic.imgdb.cn/item/63e35ca54757feff33206d07.jpg"></p><h3 id="虚拟接口配置-1"><a href="#虚拟接口配置-1" class="headerlink" title="虚拟接口配置"></a>虚拟接口配置</h3><p>点击<code>生成新的密钥对</code>生成本机的公钥和私钥，并填写下方我们规划好的此设备在wireguard虚拟网络中的ip，由于此地无公网ip所以监听端口是否配置其实无所谓（默认其实会开一个）</p><p><img src="https://pic.imgdb.cn/item/63e360e14757feff3327f0fc.jpg"></p><p>记得配置此接口所在的防火墙区域</p><p><img src="https://pic.imgdb.cn/item/63e35e1e4757feff3322f9de.jpg"></p><h3 id="配置对端（A地路由信息）"><a href="#配置对端（A地路由信息）" class="headerlink" title="配置对端（A地路由信息）"></a>配置对端（A地路由信息）</h3><p>在对端选项卡中添加一个对端，并填入A路由的对应信息<br><img src="https://pic.imgdb.cn/item/63e361984757feff33294b6a.jpg"><br>在允许的ip选项中除了要填A端路由在虚拟网络中的ip（10.0.0.1&#x2F;24）外，要加A地LAN的网段（192.168.1.0&#x2F;24）</p><p>私钥和预共享密钥为可选项。</p><h3 id="配置静态路由-1"><a href="#配置静态路由-1" class="headerlink" title="配置静态路由"></a>配置静态路由</h3><p>为了让局域网下的设备访问到对端网段下的设备，最好请添加以下静态路由（实测好像不加也没事）</p><p><img src="https://pic.imgdb.cn/item/63e3628d4757feff332b1a01.jpg"></p><p>上图中的含义为：当接口区域<code>wg</code>有去往<code>192.168.10.0/24</code>网段的数据包时，将其网关设为本机在<code>wireguard</code>虚拟网络中的ip地址</p><h2 id="A地路由的对端设置"><a href="#A地路由的对端设置" class="headerlink" title="A地路由的对端设置"></a>A地路由的对端设置</h2><p>回到A地路由器的配置，我们将B端信息填入对端选项卡中并保存应用</p><p><img src="https://pic.imgdb.cn/item/63e3634a4757feff332c6b98.jpg"></p><h2 id="使配置生效"><a href="#使配置生效" class="headerlink" title="使配置生效"></a>使配置生效</h2><p>在保存并应用配置后就已完成所有配置项，但建议重启wg虚拟端口，最好直接重启路由器，以免系统抽风没有无法正常使用。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;失踪几个月终于更新了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;事情是这样的，早在2022年我换上了Pixe之后惊奇的发现android13默默移除了L2TP的支持，只能使用IPsec的VPN了，对于我这样的懒狗来说，配置IPsec是不可能的，这辈子都是不可能的&lt;/p&gt;
&lt;p&gt;所以！我换掉了原先家中使用的某品牌成品AC，改用支持&lt;code&gt;wireguard&lt;/code&gt;的Openwrt开发板来作为主路由使用。并开始了这一次的折腾&lt;/p&gt;</summary>
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="openwrt" scheme="https://blog.xianyu.one/tags/openwrt/"/>
    
    <category term="VPN" scheme="https://blog.xianyu.one/tags/VPN/"/>
    
    <category term="异地组网" scheme="https://blog.xianyu.one/tags/%E5%BC%82%E5%9C%B0%E7%BB%84%E7%BD%91/"/>
    
    <category term="wireguard" scheme="https://blog.xianyu.one/tags/wireguard/"/>
    
  </entry>
  
  <entry>
    <title>安全启动时在Linux下使用VMware</title>
    <link href="https://blog.xianyu.one/2022/08/31/Linux/tutorial/vmware-on-ubuntu/"/>
    <id>https://blog.xianyu.one/2022/08/31/Linux/tutorial/vmware-on-ubuntu/</id>
    <published>2022-08-31T13:20:12.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<p>由于莫名其妙的原因，在ubunut下使用VMware workstation需要手动编译<code>vmnet</code>和<code>vmmon</code>，而对于自己编译安装的内核组件来说，在bios启用安全启动选项的情况下是没法正常使用的，所以这时候我们就需要手工给内核签名了</p><h1 id="首次使用"><a href="#首次使用" class="headerlink" title="首次使用"></a>首次使用</h1><p>复制以下内容即可,请使用root用户</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /root/vmware<span class="token builtin class-name">cd</span> /root/vmware<span class="token function">git</span> clone https://github.com/mkubecek/vmware-host-modules<span class="token builtin class-name">cd</span> vmware-host-modules<span class="token function">git</span> checkout workstation-16.2.3<span class="token function">sudo</span> <span class="token function">make</span> <span class="token punctuation">;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>openssl req <span class="token parameter variable">-new</span> <span class="token parameter variable">-x509</span> <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-keyout</span> MOK.priv <span class="token parameter variable">-outform</span> DER <span class="token parameter variable">-out</span> MOK.der <span class="token parameter variable">-nodes</span> <span class="token parameter variable">-days</span> <span class="token number">36500</span> <span class="token parameter variable">-subj</span> <span class="token string">"/CN=VMware/"</span>/usr/src/linux-headers-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> <span class="token parameter variable">-r</span><span class="token variable">`</span></span>/scripts/sign-file sha256 ./MOK.priv ./MOK.der <span class="token variable"><span class="token variable">$(</span>modinfo <span class="token parameter variable">-n</span> vmmon<span class="token variable">)</span></span>/usr/src/linux-headers-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> <span class="token parameter variable">-r</span><span class="token variable">`</span></span>/scripts/sign-file sha256 ./MOK.priv ./MOK.der <span class="token variable"><span class="token variable">$(</span>modinfo <span class="token parameter variable">-n</span> vmnet<span class="token variable">)</span></span>mokutil <span class="token parameter variable">--import</span> MOK.der<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>重启一次，并根据向导接受签名</p><h1 id="后续使用"><a href="#后续使用" class="headerlink" title="后续使用"></a>后续使用</h1><p>每次更新系统内核后都需要重新签名，使用以下命令即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">rm</span> <span class="token parameter variable">-rf</span> /root/vmware/vmware-host-modules<span class="token builtin class-name">cd</span> /root/vmware<span class="token function">git</span> clone https://github.com/mkubecek/vmware-host-modules<span class="token builtin class-name">cd</span> vmware-host-modules<span class="token function">git</span> checkout workstation-16.2.3<span class="token function">sudo</span> <span class="token function">make</span> <span class="token punctuation">;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span class="token builtin class-name">cd</span> /root/vmware<span class="token function">sudo</span> /usr/src/linux-headers-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> <span class="token parameter variable">-r</span><span class="token variable">`</span></span>/scripts/sign-file sha256 ./MOK.priv ./MOK.der <span class="token variable"><span class="token variable">$(</span>modinfo <span class="token parameter variable">-n</span> vmmon<span class="token variable">)</span></span><span class="token function">sudo</span> /usr/src/linux-headers-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> <span class="token parameter variable">-r</span><span class="token variable">`</span></span>/scripts/sign-file sha256 ./MOK.priv ./MOK.der <span class="token variable"><span class="token variable">$(</span>modinfo <span class="token parameter variable">-n</span> vmnet<span class="token variable">)</span></span>mokutil <span class="token parameter variable">--import</span> MOK.der<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>其实Linux下使用KVM跑虚拟机会比使用VMware的体验好太多，在没有特别要求使用VMware的情况下强烈建议使用KVM。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于莫名其妙的原因，在ubunut下使用VMware workstation需要手动编译&lt;code&gt;vmnet&lt;/code&gt;和&lt;code&gt;vmmon&lt;/code&gt;，而对于自己编译安装的内核组件来说，在bios启用安全启动选项的情况下是没法正常使用的，所以这时候我们就需要手工</summary>
      
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://blog.xianyu.one/tags/Linux/"/>
    
    <category term="VMware" scheme="https://blog.xianyu.one/tags/VMware/"/>
    
    <category term="虚拟机" scheme="https://blog.xianyu.one/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用docker部署onedrive容器</title>
    <link href="https://blog.xianyu.one/2022/08/27/onedrive-on-docker/"/>
    <id>https://blog.xianyu.one/2022/08/27/onedrive-on-docker/</id>
    <published>2022-08-27T07:56:47.000Z</published>
    <updated>2025-02-11T12:56:25.426Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见，我终于更新了……<br>原本计划是要更新kubernetes相关文章的，但是：</p><blockquote><p>🕊️了</p></blockquote><p>今天来讲解onedrive的事</p><h1 id="为什么要用docker部署onedrive？"><a href="#为什么要用docker部署onedrive？" class="headerlink" title="为什么要用docker部署onedrive？"></a>为什么要用docker部署onedrive？</h1><p>众所周知我人是非常非常非常！！！讨厌Windows的，所以目前我已经全面转向使用Linux了。<br>虽然是已全面转向Windows，但Office365还续着费呢，并且由于<a href="https://share.xianyu.one/">分享站</a>，以及移动端的需求，我也不打算停止续费。<br>既然如此，那必定是需要把Onedrive利用起来的。</p><p>由于微软“强大的”开发实力，并没有为linux推出官方的onedrive客户端，所以我们就需要自己动手部署第三方的了</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>这里可以直接使用脚本安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://get.docker.com <span class="token operator">|</span> <span class="token function">bash</span> <span class="token parameter variable">-s</span> <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>对于国内的小伙伴可以使用以下脚本</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://get.docker.com <span class="token operator">|</span> <span class="token function">bash</span> <span class="token parameter variable">-s</span> <span class="token function">docker</span> <span class="token parameter variable">--mirror</span> Aliyun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="确定文件夹位置"><a href="#确定文件夹位置" class="headerlink" title="确定文件夹位置"></a>确定文件夹位置</h2><p>这次我们使用的是来自<a href="https://github.com/abraunegg/onedrive">abraunegg&#x2F;onedrive</a>的第三方客户端，同时使用docker部署，以避免可能遇到的各种各样奇奇怪怪的问题。</p><p>对于docker部署来说，我们主要用到两个文件夹:</p><table><thead><tr><th align="center">容器路径</th><th align="center">说明</th><th align="center">主机路径推荐</th></tr></thead><tbody><tr><td align="center">&#x2F;onedrive&#x2F;conf</td><td align="center">用于放置数据库以及TOKEN</td><td align="center">~&#x2F;docker&#x2F;onedrive&#x2F;conf</td></tr><tr><td align="center">&#x2F;onedrive&#x2F;data</td><td align="center">onedrive的文件夹（默认为onedrive根目录）</td><td align="center">~&#x2F;OneDrive</td></tr></tbody></table><p>以上是我储存数据的位置</p><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ~/docker/onedrive/conf<span class="token function">mkdir</span> ~/OneDrive <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h1 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h1><p><strong>注意：使用这个客户端双向同步的话将完全同步OneDrive下的所有文件，如果OneDrive中有巨量文件的话将占用大量本地磁盘空间！</strong></p><h2 id="首次运行"><a href="#首次运行" class="headerlink" title="首次运行"></a>首次运行</h2><p>首次运行请参照以下格式运行：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> onedrive <span class="token parameter variable">-v</span> /home/<span class="token variable">$&#123;<span class="token environment constant">USER</span>&#125;</span>/docker/onedrive/conf:/onedrive/conf <span class="token punctuation">\</span>    <span class="token parameter variable">-v</span> <span class="token string">"/home/<span class="token variable">$&#123;<span class="token environment constant">USER</span>&#125;</span>/OneDrive:/onedrive/data"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-e</span> <span class="token string">"ONEDRIVE_UID=<span class="token variable">$&#123;<span class="token environment constant">UID</span>&#125;</span>"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-e</span> <span class="token string">"ONEDRIVE_GID=<span class="token variable">$&#123;GID&#125;</span>"</span> <span class="token punctuation">\</span>    driveone/onedrive:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>请将以上命令按照下方步骤填充好</p><h3 id="确定用户文件夹绝对路径"><a href="#确定用户文件夹绝对路径" class="headerlink" title="确定用户文件夹绝对路径"></a>确定用户文件夹绝对路径</h3><p>使用以下命令可以确定用户文件夹路径</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">cd ~&#x2F;pwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>输出结果为用户文件夹路径，例如我的为： <code>/home/xianyu</code></p><h3 id="确定自己的用户ID以及组ID"><a href="#确定自己的用户ID以及组ID" class="headerlink" title="确定自己的用户ID以及组ID"></a>确定自己的用户ID以及组ID</h3><p>请务必确定好自己的用户ID以及组ID，如果不使用正确的用户ID以及组ID将有极大可能无法正常访问使用文件夹下的文件！</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这里我的UID和GID均为<code>1000</code></p><h3 id="填充命令并执行"><a href="#填充命令并执行" class="headerlink" title="填充命令并执行"></a>填充命令并执行</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> onedrive <span class="token parameter variable">-v</span> /home/xianyu/docker/onedrive/conf:/onedrive/conf <span class="token punctuation">\</span>    <span class="token parameter variable">-v</span> <span class="token string">"/home/xianyu/OneDrive:/onedrive/data"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-e</span> <span class="token string">"ONEDRIVE_UID=1000"</span> <span class="token punctuation">\</span>    <span class="token parameter variable">-e</span> <span class="token string">"ONEDRIVE_GID=1000"</span> <span class="token punctuation">\</span>    driveone/onedrive:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="获取TOKEN"><a href="#获取TOKEN" class="headerlink" title="获取TOKEN"></a>获取TOKEN</h3><p>在执行完上方命令后，命令行会输出一个URL，复制到浏览器后打开，将会登录微软帐号。<br>按照指示操作完后页面会全白，此时不要担心，不是电脑网络不好，只需要将此时浏览器上的URL填入容器输出窗口并回车即可完成首次的设置。<br><img src="https://pic.imgdb.cn/item/6309d71416f2c2beb18a77e2.jpg"></p><h3 id="删除首次运行使用的容器"><a href="#删除首次运行使用的容器" class="headerlink" title="删除首次运行使用的容器"></a>删除首次运行使用的容器</h3><p>查找容器ID</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将首次运行用的容器删除</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token operator">&lt;</span>ID<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="使用docker-compose运行"><a href="#使用docker-compose运行" class="headerlink" title="使用docker-compose运行"></a>使用docker-compose运行</h1><p><strong>注意：使用docker-compose运行也必须经过上方首次运行的步骤，先确保获取到TOKEN并填入容器！</strong></p><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>下载二进制文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token string">"https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-s</span><span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> <span class="token parameter variable">-m</span><span class="token variable">)</span></span>"</span> <span class="token parameter variable">-o</span> /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>也可使用国内镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> <span class="token parameter variable">-s</span><span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> <span class="token parameter variable">-m</span><span class="token variable">`</span></span> <span class="token operator">></span> /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="下载完成后赋予可执行权限"><a href="#下载完成后赋予可执行权限" class="headerlink" title="下载完成后赋予可执行权限"></a>下载完成后赋予可执行权限</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="编写docker-compose文件"><a href="#编写docker-compose文件" class="headerlink" title="编写docker-compose文件"></a>编写docker-compose文件</h2><p>我习惯将文件放在<code>~/docker/onedrive</code>文件夹下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/docker/onedrive<span class="token function">vim</span> ~/docker/onedrive/docker-compose.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>文件内容就是将首次运行时的docker命令变为配置文件的形式</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>    <span class="token key atrule">onedrive</span><span class="token punctuation">:</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> driveone/onedrive<span class="token punctuation">:</span>latest        <span class="token key atrule">restart</span><span class="token punctuation">:</span> unless<span class="token punctuation">-</span>stopped        <span class="token key atrule">environment</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> ONEDRIVE_UID=1000            <span class="token punctuation">-</span> ONEDRIVE_GID=1000        <span class="token key atrule">volumes</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> /home/xianyu/docker/onedrive/conf<span class="token punctuation">:</span>/onedrive/conf            <span class="token punctuation">-</span> /home/xianyu/OneDrive<span class="token punctuation">:</span>/onedrive/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/docker/onedrive<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h1 id="当修改了微软账户密码"><a href="#当修改了微软账户密码" class="headerlink" title="当修改了微软账户密码"></a>当修改了微软账户密码</h1><p>在修改了微软账户密码后，容器就会无法使用TOKEN进行同步，此时需要重新部署容器，按照官方文档的操作方法，需要先停止并删除容器，再在启动时添加一条变量退出登录并清楚conf文件夹下内容。和我一样嫌麻烦的同学可以按照下方操作进行重新登录</p><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/docker/onedrive<span class="token function">docker-compose</span> down<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="删除TOKEN文件"><a href="#删除TOKEN文件" class="headerlink" title="删除TOKEN文件"></a>删除TOKEN文件</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token parameter variable">-rf</span> /home/xianyu/docker/onedrive/conf/refresh_token<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="重复首次部署流程"><a href="#重复首次部署流程" class="headerlink" title="重复首次部署流程"></a>重复首次部署流程</h2><p>接下去的操作与首次部署时完全一致，使用docker命令部署容器，并输入URL即可重新登录</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><p>除了必须全量同步这一点上非常蛋疼外什么都好<br><img src="https://pic.imgdb.cn/item/6309dc1116f2c2beb18ddd62.jpg"><br>你也可以像我一样将文件夹图标改成OneDrive的Logo，让它看起来更加没有违合感</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久不见，我终于更新了……&lt;br&gt;原本计划是要更新kubernetes相关文章的，但是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🕊️了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天来讲解onedrive的事&lt;/p&gt;
&lt;h1 id=&quot;为什么要用docker部署onedr</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.xianyu.one/tags/Linux/"/>
    
    <category term="docker" scheme="https://blog.xianyu.one/tags/docker/"/>
    
    <category term="容器" scheme="https://blog.xianyu.one/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker配置TLS认证</title>
    <link href="https://blog.xianyu.one/2022/05/07/docker/docker-daemon-tls/"/>
    <id>https://blog.xianyu.one/2022/05/07/docker/docker-daemon-tls/</id>
    <published>2022-05-07T03:54:20.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<p>当拥有不只一台Linux服务器的时候就会想着把多台服务器的docker进行统一管理，而直接使用docker daemon socket是很不安全的，应为没有任何加密并且没有身份验证，任何人知道暴露的端口就可以操作本机的docker，而docker需要root权限运行，所以约等于让人得到了root权限。<br>为了解决这个问题，就需要启用证书的认证。</p><h1 id="使用的平台"><a href="#使用的平台" class="headerlink" title="使用的平台"></a>使用的平台</h1><p>注：服务器信息经过处理</p><ul><li>Portainer Web服务器 地址：192.168.1.1</li><li>须启用docker daemon socket的远程主机 地址：192.168.2.1<br>两台主机系统均为Debian，并已经安装好了Docker</li></ul><p>申请证书、修改配置这些操作均在<code>须启用docker daemon socket的远程主机</code>进行操作</p><h1 id="签发证书"><a href="#签发证书" class="headerlink" title="签发证书"></a>签发证书</h1><p>这里使用自签名证书<br>这里创建一个文件夹用于存放所有证书</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /home/ca<span class="token builtin class-name">cd</span> /home/ca<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="生成-CA-公钥和私钥"><a href="#生成-CA-公钥和私钥" class="headerlink" title="生成 CA 公钥和私钥"></a>生成 CA 公钥和私钥</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl genrsa <span class="token parameter variable">-aes256</span> <span class="token parameter variable">-out</span> ca-key.pem <span class="token number">4096</span>openssl req <span class="token parameter variable">-new</span> <span class="token parameter variable">-x509</span> <span class="token parameter variable">-days</span> <span class="token number">3650</span> <span class="token parameter variable">-key</span> ca-key.pem <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-out</span> ca.pem  <span class="token comment">#此处创建的证书为十年，绝对够用到换服务器了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="创建-Server-端证书"><a href="#创建-Server-端证书" class="headerlink" title="创建 Server 端证书"></a>创建 Server 端证书</h2><p>请自行替换<code>本机地址</code>与<code>本机域名</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl genrsa <span class="token parameter variable">-out</span> server-key.pem <span class="token number">4096</span>openssl req <span class="token parameter variable">-subj</span> <span class="token string">"/CN=本机地址"</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> server-key.pem <span class="token parameter variable">-out</span> server.csr<span class="token builtin class-name">echo</span> subjectAltName <span class="token operator">=</span> DNS:本机域名,IP:本机地址,IP:127.0.0.1 <span class="token operator">>></span> extfile.cnf<span class="token builtin class-name">echo</span> extendedKeyUsage <span class="token operator">=</span> serverAuth <span class="token operator">>></span> extfile.cnfopenssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">3650</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-in</span> server.csr <span class="token parameter variable">-CA</span> ca.pem <span class="token parameter variable">-CAkey</span> ca-key.pem  <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-out</span> server-cert.pem <span class="token parameter variable">-extfile</span> extfile.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="创建-client-证书"><a href="#创建-client-证书" class="headerlink" title="创建 client 证书"></a>创建 client 证书</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl genrsa <span class="token parameter variable">-out</span> key.pem <span class="token number">4096</span>openssl req <span class="token parameter variable">-subj</span> <span class="token string">'/CN=此处填写对端主机地址'</span> <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> key.pem <span class="token parameter variable">-out</span> client.csr<span class="token builtin class-name">echo</span> extendedKeyUsage <span class="token operator">=</span> clientAuth <span class="token operator">></span> extfile-client.cnfopenssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">3650</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-in</span> client.csr <span class="token parameter variable">-CA</span> ca.pem <span class="token parameter variable">-CAkey</span> ca-key.pem <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-out</span> cert.pem <span class="token parameter variable">-extfile</span> extfile-client.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1 id="修改docker的配置"><a href="#修改docker的配置" class="headerlink" title="修改docker的配置"></a>修改docker的配置</h1><h2 id="修改-etc-default-docker文件"><a href="#修改-etc-default-docker文件" class="headerlink" title="修改&#x2F;etc&#x2F;default&#x2F;docker文件"></a>修改&#x2F;etc&#x2F;default&#x2F;docker文件</h2><p>这里需要向文件中写入以下内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">DOCKER_OPTS&#x3D;&quot; -H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock --tls  --tlscacert &#x2F;home&#x2F;ca&#x2F;ca.pem --tlscert &#x2F;home&#x2F;ca&#x2F;server-cert.pem  --tlskey &#x2F;home&#x2F;ca&#x2F;server-key.pem&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="修改-lib-systemd-system-docker-service文件"><a href="#修改-lib-systemd-system-docker-service文件" class="headerlink" title="修改&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service文件"></a>修改&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service文件</h2><p>修改或添加以下内容</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">EnvironmentFile&#x3D;&#x2F;etc&#x2F;default&#x2F;dockerExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H fd:&#x2F;&#x2F; $DOCKER_OPTS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reload<span class="token function">service</span> <span class="token function">docker</span> restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h1 id="修改ufw"><a href="#修改ufw" class="headerlink" title="修改ufw"></a>修改ufw</h1><p>根据上方修改的配置，我们的docker会监听来自<code>2375</code>端口的请求，所以我们需要放行<code>2375</code>端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw allow <span class="token number">2375</span>ufw <span class="token builtin class-name">enable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h1 id="连接远端的主机"><a href="#连接远端的主机" class="headerlink" title="连接远端的主机"></a>连接远端的主机</h1><p>现在我们回到<code>Portainer Web服务器</code>，可参考下图经行连接远程主机<br><img src="https://pic.imgdb.cn/item/6275f36d09475431290f93df.jpg"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><ul><li><a href="https://beixiu.net/dev/Docker%E9%85%8D%E7%BD%AETLS%E8%AE%A4%E8%AF%81%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/">Docker配置TLS认证开启远程访问</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当拥有不只一台Linux服务器的时候就会想着把多台服务器的docker进行统一管理，而直接使用docker daemon socket是很不安全的，应为没有任何加密并且没有身份验证，任何人知道暴露的端口就可以操作本机的docker，而docker需要root权限运行，所以约</summary>
      
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://blog.xianyu.one/tags/Linux/"/>
    
    <category term="Docker" scheme="https://blog.xianyu.one/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>解决VMware在更新到Ubuntu22.04LTS后无法使用的问题</title>
    <link href="https://blog.xianyu.one/2022/04/24/Linux/tutorial/vmware-work-on-Ubuntu2204/"/>
    <id>https://blog.xianyu.one/2022/04/24/Linux/tutorial/vmware-work-on-Ubuntu2204/</id>
    <published>2022-04-24T14:14:29.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<p>在更新到Ubuntu22.04后，VMware会因为<code>vmnet</code>和<code>vmmon</code>安装失败而无法运行，解决方法很简单，手动编译安装即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;lib&#x2F;vmware&#x2F;modules&#x2F;sourcegit clone https:&#x2F;&#x2F;github.com&#x2F;mkubecek&#x2F;vmware-host-modulescd vmware-host-modulesgit checkout workstation-16.2.3maketar -cf vmnet.tar vmnet-onlytar -cf vmmon.tar vmmon-onlymv vmnet.tar &#x2F;usr&#x2F;lib&#x2F;vmware&#x2F;modules&#x2F;source&#x2F;mv vmmon.tar &#x2F;usr&#x2F;lib&#x2F;vmware&#x2F;modules&#x2F;source&#x2F;vmware-modconfig --console --install-all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>执行完后重新启动VMware即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在更新到Ubuntu22.04后，VMware会因为&lt;code&gt;vmnet&lt;/code&gt;和&lt;code&gt;vmmon&lt;/code&gt;安装失败而无法运行，解决方法很简单，手动编译安装即可。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre cla</summary>
      
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://blog.xianyu.one/tags/Linux/"/>
    
    <category term="VMware" scheme="https://blog.xianyu.one/tags/VMware/"/>
    
    <category term="虚拟机" scheme="https://blog.xianyu.one/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ufw简易使用教程</title>
    <link href="https://blog.xianyu.one/2022/03/22/Linux/tutorial/ufw/"/>
    <id>https://blog.xianyu.one/2022/03/22/Linux/tutorial/ufw/</id>
    <published>2022-03-22T04:22:24.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是ufw"><a href="#什么是ufw" class="headerlink" title="什么是ufw"></a>什么是ufw</h1><p>全称<code>Uncomplicated Firewall</code>，是一个<code>iptables</code>的接口，可以简单理解为ufw是一个用于管理<code>iptables</code>的工具，由于其命令简洁便于使用、同时支持IPv4、IPv6而受到我本人的欢迎。</p><span id="more"></span><h1 id="为什么要用ufw"><a href="#为什么要用ufw" class="headerlink" title="为什么要用ufw"></a>为什么要用ufw</h1><p>来对比一下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#iptables开放22端口</span>iptables <span class="token parameter variable">-A</span> INPUT <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--dport</span> <span class="token number">22</span> <span class="token parameter variable">-j</span> ACCEPTiptables <span class="token parameter variable">-A</span> OUTPUT <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--sport</span> <span class="token number">22</span> <span class="token parameter variable">-j</span> ACCEPT<span class="token comment">#ufw开放22端口</span>ufw allow <span class="token number">22</span>/tcpufw <span class="token builtin class-name">enable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>你说为什么要用ufw<br>当然是简单啊！</p><h1 id="安装ufw"><a href="#安装ufw" class="headerlink" title="安装ufw"></a>安装ufw</h1><h2 id="Ubuntu-Debian"><a href="#Ubuntu-Debian" class="headerlink" title="Ubuntu&#x2F;Debian"></a>Ubuntu&#x2F;Debian</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ufw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="CentOS-RHEL"><a href="#CentOS-RHEL" class="headerlink" title="CentOS&#x2F;RHEL"></a>CentOS&#x2F;RHEL</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">sudo yum install ufw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="设置默认规则"><a href="#设置默认规则" class="headerlink" title="设置默认规则"></a>设置默认规则</h1><p><strong>注意：从本章节开始所有命令都是在root权限下执行的，请提前切换到root用户！<del>我实在懒得把sudo打出来了</del></strong><br>虽然一般来说刚刚安装好的ufw本来就不包含规则，但最好还是先拒绝所有传入的连接再按照自己的需求配置比较好。（<strong>此处配置完后千万不要直接执行</strong><code>ufw enable</code><strong>对这两条命令进行应用</strong>）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw default allow outgoing <span class="token comment">#默认允许所有数据出站</span>ufw default deny incoming <span class="token comment">#默认禁止所有数据入站</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><code>ufw default</code>命令意为：默认xxx<br><code>allow</code>和<code>deny</code>详见下图：<br><img src="https://pic.imgdb.cn/item/6239577c27f86abb2ae940c4.jpg" alt="没别的意思"><br><img src="https://pic.imgdb.cn/item/6239574e27f86abb2ae87277.jpg" alt="这两个单词不认识实在不应该"></p><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="查看当前规则"><a href="#查看当前规则" class="headerlink" title="查看当前规则"></a>查看当前规则</h2><p>你可以使用以下命令查看已生效的规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw statusufw status numbered  <span class="token comment">#这条会让列出的规则前面加上数字编号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="允许或禁止某端口-某服务传入和传出流量"><a href="#允许或禁止某端口-某服务传入和传出流量" class="headerlink" title="允许或禁止某端口&#x2F;某服务传入和传出流量"></a>允许或禁止某端口&#x2F;某服务传入和传出流量</h2><p>以允许22端口为例</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw allow <span class="token number">22</span>ufw deny <span class="token number">22</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>真的超级简单。</p><h3 id="仅仅允许某端口的TCP-UDP的流量"><a href="#仅仅允许某端口的TCP-UDP的流量" class="headerlink" title="仅仅允许某端口的TCP&#x2F;UDP的流量"></a>仅仅允许某端口的TCP&#x2F;UDP的流量</h3><p>在端口号后加上<code>/tcp</code>或<code>/udp</code>即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw allow <span class="token number">22</span>/tcpufw allow <span class="token number">22</span>/udp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="通过应用名来允许或禁止某项服务的流量（默认的端口）"><a href="#通过应用名来允许或禁止某项服务的流量（默认的端口）" class="headerlink" title="通过应用名来允许或禁止某项服务的流量（默认的端口）"></a>通过应用名来允许或禁止某项服务的流量（默认的端口）</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw allow <span class="token function">ssh</span>ufw deny <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>上面两条命令等同于</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw allow <span class="token number">22</span>/tcpufw deny <span class="token number">22</span>/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>你也可以通过这个方法来禁用</p><h2 id="使配置生效"><a href="#使配置生效" class="headerlink" title="使配置生效"></a>使配置生效</h2><p>为了使我们输入的配置生效，请使用以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw <span class="token builtin class-name">enable</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw disable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="删除生效的规则"><a href="#删除生效的规则" class="headerlink" title="删除生效的规则"></a>删除生效的规则</h2><p>你可以通过以下格式删除规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw delete allow <span class="token function">ssh</span>ufw delete allow <span class="token number">22</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>或者根据<code>ufw status numbered</code>给出的列表前的数字编号删除</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw delete <span class="token number">1</span> <span class="token comment">#删除编号为1的规则</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h2 id="允许某IP或IP地址段访问某端口"><a href="#允许某IP或IP地址段访问某端口" class="headerlink" title="允许某IP或IP地址段访问某端口"></a>允许某IP或IP地址段访问某端口</h2><h3 id="允许某IP或IP地址段访问本机所有端口"><a href="#允许某IP或IP地址段访问本机所有端口" class="headerlink" title="允许某IP或IP地址段访问本机所有端口"></a>允许某IP或IP地址段访问本机所有端口</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw allow from <span class="token number">192.168</span>.1.1  <span class="token comment">#允许某IP访问</span>ufw allow frome <span class="token number">192.168</span>.1.0/24  <span class="token comment">#允许某IP段访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="某IP或IP地址段访问本机某特定端口"><a href="#某IP或IP地址段访问本机某特定端口" class="headerlink" title="某IP或IP地址段访问本机某特定端口"></a>某IP或IP地址段访问本机某特定端口</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw allow from <span class="token number">192.168</span>.1.1 any port <span class="token number">22</span>  <span class="token comment">#允许某IP访问</span>ufw allow from <span class="token number">192.168</span>.1.0/24 any port <span class="token number">22</span>  <span class="token comment">#允许某IP段访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="禁ping，仅允许特定IP使用ping"><a href="#禁ping，仅允许特定IP使用ping" class="headerlink" title="禁ping，仅允许特定IP使用ping"></a>禁ping，仅允许特定IP使用ping</h2><h3 id="检查是否已经关闭了icmp服务"><a href="#检查是否已经关闭了icmp服务" class="headerlink" title="检查是否已经关闭了icmp服务"></a>检查是否已经关闭了icmp服务</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/ufw/sysctl.conf <span class="token operator">|</span> <span class="token function">grep</span> net/ipv4/icmp_echo_ignore_all<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果输出结果为<code>net/ipv4/icmp_echo_ignore_all=1</code>则需要到文件里把它改为<code>net/ipv4/icmp_echo_ignore_all=0</code></p><h3 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h3><p>在<code>/etc/ufw/before.rules</code>中添加规则</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">-A ufw-before-input -p icmp --icmp-type echo-request -s 此处填写IPv4地址或地址段 -m state --state ESTABLISHED -j ACCEPT-A ufw6-before-input -p icmpv6 --icmpv6-type echo-request -s 此处填写IPv6地址或地址段 -m state --state ESTABLISHED -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="重新加载配置"><a href="#重新加载配置" class="headerlink" title="重新加载配置"></a>重新加载配置</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ufw reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://tstrs.me/1480.html">非常简单的 UFW 防火墙使用教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/98880088">简明教程｜Linux中UFW的使用</a></li><li><a href="https://stackoverflow.com/questions/16376101/ufw-allow-ping-requests-only-for-specific-host">UFW: Allow ping requests only for specific host</a></li><li><a href="https://www.cnblogs.com/zqifa/p/ubuntu-ufw-1.html">ubuntu防火墙ufw使用教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是ufw&quot;&gt;&lt;a href=&quot;#什么是ufw&quot; class=&quot;headerlink&quot; title=&quot;什么是ufw&quot;&gt;&lt;/a&gt;什么是ufw&lt;/h1&gt;&lt;p&gt;全称&lt;code&gt;Uncomplicated Firewall&lt;/code&gt;，是一个&lt;code&gt;iptables&lt;/code&gt;的接口，可以简单理解为ufw是一个用于管理&lt;code&gt;iptables&lt;/code&gt;的工具，由于其命令简洁便于使用、同时支持IPv4、IPv6而受到我本人的欢迎。&lt;/p&gt;</summary>
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://blog.xianyu.one/tags/Linux/"/>
    
    <category term="ufw" scheme="https://blog.xianyu.one/tags/ufw/"/>
    
    <category term="防火墙" scheme="https://blog.xianyu.one/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="Debian" scheme="https://blog.xianyu.one/tags/Debian/"/>
    
    <category term="Ubuntu" scheme="https://blog.xianyu.one/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Linux挂载非标准端口SMB</title>
    <link href="https://blog.xianyu.one/2022/03/21/Linux/yes/SMB/"/>
    <id>https://blog.xianyu.one/2022/03/21/Linux/yes/SMB/</id>
    <published>2022-03-21T03:51:04.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近开始换用Linux作为主要系统了，打算写一个系列来介绍为什么Linux比Windows好用。这是第一篇。<br/>   <span id="more"></span><br>由于SMB服务的445端口会被用于传播例如永恒之蓝等的Windows病毒，所以一般国内的运营商会直接封锁445端口，这也就导致了我们无法直接在外网使用标准端口访问家中nas上的SMB服务。而Winodws又因为其非常弱智的设计——不允许用户使用非标准端口挂载SMB，所以在Windows的公网环境下无法愉快的使用网络硬盘。当然，你也可以用端口转发的方式实现Windows挂载非标准端口的SMB（反正我没有成功过）。<br/><br>总之，我不喜欢使用Windows，也的确不熟悉这个系统的一些原理，所以我也不打算在Windows环境下折腾了。来玩Linux吧！<br/></p><!--more--><h1 id="挂载SMB的前置准备"><a href="#挂载SMB的前置准备" class="headerlink" title="挂载SMB的前置准备"></a>挂载SMB的前置准备</h1><h2 id="在挂载网络硬盘前首先要下载相关的软件包"><a href="#在挂载网络硬盘前首先要下载相关的软件包" class="headerlink" title="在挂载网络硬盘前首先要下载相关的软件包"></a>在挂载网络硬盘前首先要下载相关的软件包</h2><p>Debian&#x2F;Ubuntu下</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> cifs-utils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>CentOS&#x2F;RHEL</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> cifs-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="创建要挂载的目录"><a href="#创建要挂载的目录" class="headerlink" title="创建要挂载的目录"></a>创建要挂载的目录</h2><p>由于正常情况下我们都不会使用root用户进行日常的生产生活，所以我们把网络硬盘挂载到目前使用用户的家目录下的文件夹中才行，这里以挂载到<code>/home/xianyu/mnt/nas/disk</code>为例</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">mkdir -p &#x2F;home&#x2F;xianyu&#x2F;mnt&#x2F;nas&#x2F;disk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="如何挂载SMB"><a href="#如何挂载SMB" class="headerlink" title="如何挂载SMB"></a>如何挂载SMB</h1><p>先看我的范例</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mount</span> <span class="token parameter variable">-t</span> cifs <span class="token parameter variable">-o</span> <span class="token assign-left variable">username</span><span class="token operator">=</span>user_name,password<span class="token operator">=</span>your_password,uid<span class="token operator">=</span>xianyu,gid<span class="token operator">=</span>xianyu,port<span class="token operator">=</span><span class="token number">10086</span> //example.com/disk /home/xianyu/mnt/nas/disk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>首先来看<code>-t cifs</code>，这条指定了使用的档案系统的形态，也就是上一节安装的那个。  <br/><br>后面的<code>-o</code>参数只有root用户可以使用，所以前面要加上<code>sudo</code><br/><br>在来到<code>-o</code>后方跟着的一长串：<code>username=user_name,password=your_password,uid=xianyu,gid=xianyu,port=10086</code>，他们的含义如下：</p><table><thead><tr><th align="center">username</th><th align="center">password</th><th align="center">uid</th><th align="center">gid</th><th align="center">port</th></tr></thead><tbody><tr><td align="center">SMB服务器上登陆用的用户名</td><td align="center">SMB服务器上登陆的用户密码</td><td align="center">挂载到本地后指定的用户</td><td align="center">挂载到本地后指定的用户组</td><td align="center">SMB的端口</td></tr></tbody></table><p>这里尤其要说明一下<code>uid</code>和<code>gid</code>，由于在Linux中root用户责任重大，在正常的生产环境及个人使用时都不建议直接使用root用户进行操作，所以我们需要在挂载时指定使用普通用户、用户组进行挂载。如果不添加<code>uid</code>和<code>gid</code>参数的话，网络硬盘挂载到本地之后文件加的若属用户和用户组就是root，对于普通用户来说会没有权限对文件夹的内容进行操作。   <br/><br>最后的<code>//example.com/disk /home/xianyu/mnt/nas/disk</code>，前面的指的是SMB服务器的地址及路径，后面的就是挂载到本地的哪个位置。<br>了解完命令的意义，就可以根据自己的情况进行挂载了</p><h1 id="如何卸载SMB"><a href="#如何卸载SMB" class="headerlink" title="如何卸载SMB"></a>如何卸载SMB</h1><p>很简单，如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">umount &#x2F;home&#x2F;xianyu&#x2F;mnt&#x2F;nas&#x2F;disk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近开始换用Linux作为主要系统了，打算写一个系列来介绍为什么Linux比Windows好用。这是第一篇。&lt;br/&gt;</summary>
    
    
    
    
    <category term="Linux yes" scheme="https://blog.xianyu.one/tags/Linux-yes/"/>
    
    <category term="Linux香疯了" scheme="https://blog.xianyu.one/tags/Linux%E9%A6%99%E7%96%AF%E4%BA%86/"/>
    
    <category term="SMB" scheme="https://blog.xianyu.one/tags/SMB/"/>
    
  </entry>
  
  <entry>
    <title>sudo使用小技巧</title>
    <link href="https://blog.xianyu.one/2022/03/20/Linux/tutorial/sudoers/"/>
    <id>https://blog.xianyu.one/2022/03/20/Linux/tutorial/sudoers/</id>
    <published>2022-03-19T19:50:53.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>有时好久没更新。日常摆烂。本来想这个月更新（<del>反正我已经默认月更了</del>）一篇 Xbox Series S 的评测的，但是由于种种原因，还没受到货，所以就写点别的吧。<br><br/><span id="more"></span><br>前天开始我把自己的两台电脑都刷成了Linux系统，开始正式以Linux作为主要的操作系统使用了。<br><br/><br>作为一个Linux小白，同时由于我手头上设备都比较奇葩（一台陈年Macbook Air，一台用AMD <strong>APU</strong>的惠普笔电）所以我选择了兼容性好且对于普通用户而言相对友好的Ubuntu作为电脑的操作系统。同时，在惠普的笔电上，我还保留了（其实是重新刷入了）Windows系统，以备不时之需。<br><br/><br>作为一个懒狗，不能接受普通用户在使用例如<code>apt</code>、<code>docker</code>等命令前需要加<code>sudo</code>并且输入密码，所以就有了这次小小的折腾。</p><h1 id="sudo的简单介绍"><a href="#sudo的简单介绍" class="headerlink" title="sudo的简单介绍"></a>sudo的简单介绍</h1><p><code>sudo</code>命令的含义其实就是<code>superuser do</code>，从字面意思上看我们就能知道，它的作用是通过安全的方式让用户提权使用特殊的权限执行程序。  <br/><br>而就像我上面提到的，如果想要使用<code>sudo</code>（Ubuntu）默认创建的用户，那么需要输入自己的密码才能提权，这还挺麻烦的。  <br/><br>此时我们就可以通过修改配置文件，让用户免密使用sudo，具体的配置文件以及配置文件夹有二：配置文件<code>sudoers</code>（位置在<code>/etc/sudoers</code>）和配置文件夹<code>sudoers.d</code>(位置在<code>/etc/sudoers.d/</code>)<br>通过修改或者添加自定义的配置就可以实现免密登陆。</p><h1 id="sudoers配置应该怎么写"><a href="#sudoers配置应该怎么写" class="headerlink" title="sudoers配置应该怎么写"></a>sudoers配置应该怎么写</h1><p>先来看看两个范例：<br><br/></p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">xianyu ALL&#x3D;(root:root) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;apt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>以上配置的含义为：授权用户<code>xianyu</code>在<strong>所有</strong>主机上，以用户<code>root</code>、组<code>root</code>的身份不需要密码直接执行<code>/usr/bin/apt</code><br><br/></p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">%admin ALL&#x3D;(ALL:admin) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;docker,&#x2F;usr&#x2F;bin&#x2F;tree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>以上配置的含义为：授权用户组<code>xianyu</code>的用户在<strong>所有</strong>主机上，以所有用户身份，以组<code>admin</code>的身份不需要密码直接执行<code>/usr/bin/docker</code>或<code>/usr/bin/tree</code></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>从上面的例子我们就可以知道格式为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">#用户的格式：用户名 主机名或组&#x3D;(提权后的用户名:提权后的用户组) NOPASSWD: 命令用户名 主机名或组&#x3D;(提权后的用户名:提权后的用户组) 命令#用户组的格式：%用户组 主机名或组&#x3D;(提权后的用户名:提权后的用户组) NOPASSWD: 命令%用户组 主机名或组&#x3D;(提权后的用户名:提权后的用户组) 命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>命令可以在同一行写很多个。<br>可以在配置文件中写好主机列表、命令列表、用户列表、身份列表方便使用。<br>例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">#主机列表Host_Alias HOST_LIST&#x3D;hostname1,hostname2,hostname3#命令列表Cmnd_Alias COMMAND_LIST&#x3D;&#x2F;usr&#x2F;bin&#x2F;apt,&#x2F;usr&#x2F;bin&#x2F;docker#用户列表User_Alias USER_LIST&#x3D;xianyu,yuxian,admin#以什么身份运行Runas_Alias RUNAS_LIST&#x3D;root,adm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>接着就可以直接引用了，比如</p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">USER_LIST HOST_LIST&#x3D;(RUNAS_LIST) COMMAND_LISTUSER_LIST HOST_LIST&#x3D;(RUNAS_LIST) NOPASSWD: COMMAND_LIST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h1 id="我将怎么用"><a href="#我将怎么用" class="headerlink" title="我将怎么用"></a>我将怎么用</h1><p>首先当然是写sudoers配置文件。<strong>但是！</strong>由于Linux发行版的差异，需要修改的地方不一样，例如，Debian可以直接在配置文件<code>sudoers</code>中添加配置，而Ubuntu发行版需要进入<code>sudoer.d</code>文件夹中，新建一个文件，并将配置写入其中。我平时常用的有四个命令：<code>apt</code>、<code>apt-get</code>、<code>docker</code>、<code>snap</code>，所以我需要让普通用户免密使用以上命令，以下是我的配置文件内容：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">#配置文件路径为&#x2F;etc&#x2F;sudoers.d&#x2F;xianyuxianyu ALL&#x3D;(ALL:ALL) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;apt,&#x2F;usr&#x2F;bin&#x2F;apt-get,&#x2F;usr&#x2F;bin&#x2F;docker,&#x2F;usr&#x2F;bin&#x2F;snap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>然后，我除了嫌输密码麻烦外，多打一个<code>sudo</code>也挺麻烦的。所以为了进一步减少工作量，接下去需要修改用户主目录下的<code>.bashrc</code>。</p><h2 id="什么是bashrc"><a href="#什么是bashrc" class="headerlink" title="什么是bashrc"></a>什么是bashrc</h2><p>Linux下默认使用的shell程序是<code>bash</code>，<code>.bashrc</code>是用户登陆时会首先运行的文件（其实就是个shell脚本），所以我们只需要用<code>alias</code>命令将相关的规则写进<code>.bashrc</code>就可以一劳永逸了。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>上面我提到了四个命令，所以要在文件中添加四条</p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">alias apt&#x3D;&#39;sudo apt&#39;alias apt-get&#x3D;&#39;sudo apt&#39;alias docker&#x3D;&#39;sudo docker&#39;alias snap&#x3D;&#39;sudo snap&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>保存并退出文件，注销用户后重新登陆就能使用了。<br><code>alias</code>命令的含义就是让等号前的等同于等号后的命令，所以在之后我以普通用户执行这些命令，不再需要加sudo输密码了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;有时好久没更新。日常摆烂。本来想这个月更新（&lt;del&gt;反正我已经默认月更了&lt;/del&gt;）一篇 Xbox Series S 的评测的，但是由于种种原因，还没受到货，所以就写点别的吧。&lt;br&gt;&lt;br/&gt;</summary>
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://blog.xianyu.one/tags/Linux/"/>
    
    <category term="sudo" scheme="https://blog.xianyu.one/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>联想小新Pad Pro 2020 刷机笔记</title>
    <link href="https://blog.xianyu.one/2022/02/11/Android/Lenovo-p11-pro/"/>
    <id>https://blog.xianyu.one/2022/02/11/Android/Lenovo-p11-pro/</id>
    <published>2022-02-11T00:07:34.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我的PixelBook去年年底突然暴毙，我带着一台Windows笔记本度过了一段非常痛苦的时期，由于起其耗电量实在过于惊人（不是游戏本！！！），我不得不在上课的时候蹲到教室的最后面的插座边上给笔记本供电。<br>一个偶然的机会，我发现了联想小新Pad的这个系列产品，思来想去选择了联想小新Pad Pro 2020</p><span id="more"></span><h2 id="为什么选择它？"><a href="#为什么选择它？" class="headerlink" title="为什么选择它？"></a>为什么选择它？</h2><p>原先考虑的机器有三款：<code>Pro 2020</code>、<code>Plus</code>、<code>Pro 2021</code><br>性能及屏幕最为优秀的肯定是<code>Pro 2021</code> ，CP值最高的肯定是<code>Plus</code><br>但它们都有个各自对我来说不能忍受的缺点：<br><code>Pro 2021</code>缺少GPS支持，并且无对应的海外版本固件，虽然性能要比上一代强上太多，但6GB的运行内存加上大陆系统的搭配让我觉得不是很妙，应该说100％会卡出天际。<br><code>Plus</code>硬伤是屏幕非OLED，对于观影体验来说会大打折扣（正所谓买前生产力，买后迪士尼）  </p><br><p>最终我选择了<code>Pro 2020</code>，首先是我最关心的系统部分，**<code>Pro 2020</code>可以在不解锁BootLoader的情况下（当然是有先决条件的）直接刷入海外版固件**，同时网上已经存在大量的刷机教学（由于此机型的大陆版本相较于海外发行的版本来说价格过于香，所以有不少的台湾同胞以及海外的搞机玩家购入此款机型）<br>其次，硬件方面，730G的SoC功耗足够低，为长续航提供了保障（再也不用蹲到教室后面充电了）；同时OLED屏幕＋JBL认证的四颗喇叭＋杜比认证为良好的观影体验的提供的了强有力的保障。<br>综上所述：<br><code>Pro 2020</code> YES！</p><p>在长期的心理斗争及查询相当多资料后，我选择了购入这台Pad。</p><h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li><strong>机器拿到手之后不要升级！！！</strong></li><li><strong>机器拿到手之后不要升级！！！</strong></li><li><strong>机器拿到手之后不要升级！！！</strong><br>本篇文章中涉及到的刷机方法仅限于<strong>没有</strong>升级到<code>ZUI12.5</code>及以上版本的<code>Pro 2020</code>，如果你已经升级了，那么恭喜你，需要先行解锁BootLoader再进行刷机的动作</li></ul><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li><p>Windows系统的电脑</p></li><li><p>一根数据线</p></li></ul><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>所有使用的软件已经全部备份到了我的分享站，点击<a href="https://share.xianyu.one/od/%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/Android/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0pad%20pro%202020">这里</a>前往镜像站，所涉及的刷机工具全部都包含在内</p><h2 id="Windows-上的准备"><a href="#Windows-上的准备" class="headerlink" title="Windows 上的准备"></a>Windows 上的准备</h2><p>首先要在Windows 上安装好所需要的软件，以确保后面的流程能够正常进行</p><h3 id="安装QFIL"><a href="#安装QFIL" class="headerlink" title="安装QFIL"></a>安装QFIL</h3><p>先下载好<code>QPST.WIN.2.7.451.2.zip</code>这个文件并解压，在文件夹下有一个名为<code>setup.exe</code>的可执行文件点击安装，同意其条款后一路默认点<code>NEXT</code>就可以</p><h4 id="配置QFIL"><a href="#配置QFIL" class="headerlink" title="配置QFIL"></a>配置QFIL</h4><p>打开QFIL软件，将<code>Select BUild Type</code>中的<code>Meta Build</code>选中<br>点击上方<code>Configuratiion</code>中的<code>FireHoseConfiguration</code>并将<code>device type</code>设置为<code>UFS</code>，点击<code>OK</code>确认保存<br><img src="https://pic.imgdb.cn/item/62089cb02ab3f51d916472d2.jpg" alt="如图所示（原图来自https://club.lenovo.com.cn/thread-7805907-1-1.html）"></p><h3 id="安装HxD"><a href="#安装HxD" class="headerlink" title="安装HxD"></a>安装HxD</h3><p>下载<code>HxD安装包.zip</code>这个文件解压并安装，一样无脑<code>NEXT</code>就可以</p><h3 id="安装高通驱动"><a href="#安装高通驱动" class="headerlink" title="安装高通驱动"></a>安装高通驱动</h3><p>下载<code>高通驱动.zip</code>这个文件解压并安装，一样无脑<code>NEXT</code>就可以。<br><strong>注意：此处windows的安全软件会显示有病毒，请忽略并运行解压</strong></p><h2 id="刷入低版本海外版固件"><a href="#刷入低版本海外版固件" class="headerlink" title="刷入低版本海外版固件"></a>刷入低版本海外版固件</h2><p><strong>注意：这一步是中间步骤，请按照这个教程做完！如果你认为这样刷入海外版就可以的话升级后会变砖！升级后会变砖！升级后会变砖！</strong><br>点击<a href="https://share.xianyu.one/directlink/od/%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/Android/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0pad%20pro%202020/TB-J706F_S241015_210326_ROW.zip">此处</a>下载低版本的海外版固件(<code>TB-J706F_S241015_210326_ROW.zip</code>) ，并将其解压缩（<strong>注意：解压的路径中不可以包含任何中文字符！</strong>）<br>平板关机并按住<code>音量键+</code>，用数据线将Pad连接至电脑，并打开QFIL，如果一切顺利，上方会显示出<code>Qualcomm HS-USB QDLoader 9008</code>的字样，说明Pad已经入9008工程模式<br>接下去点击<code>Load Content</code>并进入前面解压的ROM包的文件夹中，点击<code>contents.xml</code>文件，并点击打开<br>最后点击<code>Download Content</code>进行安装即可。安装好后即为海外版的ROM，可以开机进行确认，<strong>但非常不建议直接使用！请按照本文将所有的步骤做完！</strong></p><h2 id="修改QCN"><a href="#修改QCN" class="headerlink" title="修改QCN"></a>修改QCN</h2><p>原先最早的时候刷机并没有这一步，但后来Lenovo往固件包里加了防降级、防刷海外版本的补丁，所以为了顺利刷入，无论如何要修改QCN。<br>机器关机状态下按住<code>电源键</code>及<code>音量键+</code>进入FFBM Mode，并将Pad连接至电脑<br>打开QFIL，此时如果一切顺利，上方将会显示<code>Qualcomm HS-USB Android DIAG 901D</code>的字样<br>此时选择上方<code>Tools</code>中的<code>QCN Backup Restore</code>，点击<code>Backup QCN</code>，之后等进度条读完，会有一个文件出现在选框中显示的文件夹中，例如下图所示，这个文件就保存在C盘下的<code>Temp</code>文件夹中<br><img src="https://pic.imgdb.cn/item/6208a02e2ab3f51d9167ca4f.png"></p><p><strong>警告⚠️：在编辑文档之前请务必备份此文件！</strong></p><p>接着使用HxD打开此文件，使用<code>ctrl</code>+<code>f</code>快捷键，或点击上方的<code>Seach</code>中的<code>find</code>查找字符<br>查找选框打开后选择<code>Hex-values</code>，搜索框中填入<code>88 00 01 00 CA 1A 00 00 02</code>点击<code>OK</code>进行查找（注意，此处如果你省略了上方的先刷入海外版ROM的步骤的话，请将末尾的<code>02</code>改为<code>01</code>尝试搜索）<br><strong>此处需要注意：HxD有个莫名其妙的bug，如果你第一次查找的字符并没有找到，在不关闭这个文件的情况下再次搜索，无论这个文件中包不包含匹配的字符，都会显示找不到！如果第一次没找到，请将文件关闭后重新打开再进行搜索！</strong></p><p>找到后，将末尾<code>02</code>选中，输入<code>00</code>完成修改（<code>00</code>代表不限制刷机<code>01</code>代表限制只能刷中国大陆版<code>02</code>代表限制只能刷国际版）并保存文件。</p><p>回到QFIL，还是<code>QCN Backup Restore</code>选框，点击<code>Restore QCN</code>，将文件刷入设备，在刷入过程中会提示报错，这是正常的，看到报错后不用等进度条走完（因为报错了进度条就不走了）<br>按住<code>电源键</code>+<code>音量键-</code>将Pad关机</p><h2 id="最终刷入海外版固件"><a href="#最终刷入海外版固件" class="headerlink" title="最终刷入海外版固件"></a>最终刷入海外版固件</h2><p>完成修改QCN的步骤后就可以正式刷入海外版固件了<br>点击<a href="https://share.xianyu.one/directlink/od/%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/Android/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0pad%20pro%202020/TB-J706F_S620150_211226_ROW.zip">此处</a>下载海外版固件（这个是Android11的）并解压<strong>注意：解压的路径中不可以包含任何中文字符！</strong>）<br>打开QFIL，平板关机并按住<code>音量键+</code>，用数据线将Pad连接至电脑，并打开QFIL，如果一切顺利，上方会显示出<code>Qualcomm HS-USB QDLoader 9008</code>的字样，说明Pad已经入9008工程模式<br>接下去点击<code>Load Content</code>并进入前面解压的ROM包的文件夹中，点击<code>contents.xml</code>文件，并点击打开<br>最后点击<code>Download Content</code>进行安装即可。<br>接着打开就是海外版系统了。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>海外版的系统着实比国内版看着顺眼的多，而且相对干净。由于系统预装软件的减少，一定程度上缓解了运行内存不足的问题<br><img src="https://pic.imgdb.cn/item/6208a4182ab3f51d916b78cb.jpg"><br>个人对于这块屏幕的显示素质以及影音表现都非常的认可，可以说惊艳到我了，没想到一千多人民币的设备能够做到这个程度。CP值超高<br>耗电量方面也还可以，如果持续看Disney+的影片的话，高亮度能坚持7-9个小时左右，非常够用</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="工作模式非常烂！"><a href="#工作模式非常烂！" class="headerlink" title="工作模式非常烂！"></a>工作模式非常烂！</h3><p>工作模式让我觉得非常鸡肋，首先，切换到工作模式没有过渡动画，整体显得非常生硬，同时，工作模式下，除了界面使用逻辑上会更贴近Windows这个缺点外，使用体验也很差，打开应用会有一定卡顿，小窗口加上Android的UI设计看着也非常别扭底部导航栏也过于鸡肋</p><h3 id="触摸板非常难用"><a href="#触摸板非常难用" class="headerlink" title="触摸板非常难用"></a>触摸板非常难用</h3><p>由于这款机器的原装触摸板<strong>并非是模拟鼠标，或是有专门的触摸板驱动，而是直接模拟手指触控操作，所以触摸板操作逻辑非常别扭，没有鼠标右键，且选中文字的操作也很别扭</strong></p><h3 id="实体键盘搭配使用有莫名其妙的bug"><a href="#实体键盘搭配使用有莫名其妙的bug" class="headerlink" title="实体键盘搭配使用有莫名其妙的bug"></a>实体键盘搭配使用有莫名其妙的bug</h3><p>在我的测试下，在自建的code-server的web界面下使用实体键盘并搭配中文输入法编辑文件会无法正常拼写<br><img src="https://pic.imgdb.cn/item/620669dc2ab3f51d91a40906.jpg"><br>以及Google Keep下写笔记，如果打开勾选框也会出现一模一样的问题。<br>缓解的办法就是使用实体键盘的同时将虚拟键盘也打开，但在保正中文输入的同时还会出现新的问题：</p><ul><li>如果此时切换到英文输入法，则会导致直接无法输入</li><li>大概会有一半的屏幕直接被虚拟键盘挡掉，大大减少了屏幕查看其他内容的面积</li></ul><h3 id="面部识别鸡肋"><a href="#面部识别鸡肋" class="headerlink" title="面部识别鸡肋"></a>面部识别鸡肋</h3><p>说真的，识别率很差，且打开面部识别并打开“抬起唤醒”的功能后，关闭屏幕的情况下会被莫名其妙唤醒，很弱智（不知道联想工程师是怎么想的，明明键盘都合上了，霍尔元件也能够感应到，但为什么还能被唤醒）</p><h3 id="合上键盘后莫名奇妙的唤醒"><a href="#合上键盘后莫名奇妙的唤醒" class="headerlink" title="合上键盘后莫名奇妙的唤醒"></a>合上键盘后莫名奇妙的唤醒</h3><p>上一条提到了，但不完全是人脸识别到问题，因为开启“显示”设置下的“轻触即可唤醒”和“拿起平板电脑即可查看”的功能后也会出现合上键盘后莫名其妙唤醒的问题</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抛开这些“影响生产力”但莫名其妙的bug，这台平板依旧是我认为值得的，一千多人民币的价格可以购买如此优秀的屏幕及喇叭就已经值回票价，同时其便携性以及长续航可以让我不用再带充电线去上课了，总体来说，虽然有很多不足，但瑕不掩瑜，这个价格非常值得购买，也基本满足了我的需求。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://club.lenovo.com.cn/thread-7805907-1-1.html">ZUI系统小新&amp;YOGA平板线刷教程和国行底包及root（资源合集）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;我的PixelBook去年年底突然暴毙，我带着一台Windows笔记本度过了一段非常痛苦的时期，由于起其耗电量实在过于惊人（不是游戏本！！！），我不得不在上课的时候蹲到教室的最后面的插座边上给笔记本供电。&lt;br&gt;一个偶然的机会，我发现了联想小新Pad的这个系列产品，思来想去选择了联想小新Pad Pro 2020&lt;/p&gt;</summary>
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="刷机" scheme="https://blog.xianyu.one/tags/%E5%88%B7%E6%9C%BA/"/>
    
    <category term="Android" scheme="https://blog.xianyu.one/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>UNraid折腾笔记——鸟枪换炮，我的第二台NAS</title>
    <link href="https://blog.xianyu.one/2022/01/20/nas-unraid/"/>
    <id>https://blog.xianyu.one/2022/01/20/nas-unraid/</id>
    <published>2022-01-19T21:12:57.000Z</published>
    <updated>2025-02-11T12:56:25.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><h2 id="买NAS的缘由"><a href="#买NAS的缘由" class="headerlink" title="买NAS的缘由"></a>买NAS的缘由</h2><p>去年的时候由于实在是忍受不了B站对于番剧的阉割，所以入手了一台矿渣蜗牛星级作为个人的第一台NAS，开始搞自己的影音服务器<br><img src="https://pic.imgdb.cn/item/61e9368f2ab3f51d91670de9.jpg"><br>这台矿渣的配置及价格如下</p><table><thead><tr><th>设备</th><th>数量</th><th>价格</th></tr></thead><tbody><tr><td>J1900</td><td>1</td><td>&#x2F;</td></tr><tr><td>4G DDR3内存</td><td>1</td><td>&#x2F;</td></tr><tr><td>以上配置的蜗牛星际整机</td><td>1</td><td>368¥</td></tr><tr><td>3T日立翻新盘</td><td>2</td><td>536¥</td></tr><tr><td>500G西数二手盘</td><td>1</td><td>49.5¥</td></tr><tr><td>256G七彩虹SATA固态</td><td>1</td><td>179¥</td></tr><tr><td>闪迪32G U盘</td><td>1</td><td>29.9¥</td></tr><tr><td>合计</td><td>&#x2F;</td><td>1162.4¥</td></tr></tbody></table><p>用很少的钱装黑群晖组了人生第一台NAS。</p><h2 id="为什么才一年就换"><a href="#为什么才一年就换" class="headerlink" title="为什么才一年就换"></a>为什么才一年就换</h2><p>J1900的性能过于羸弱，导致我只能下载1080p的且是h264的资源，外挂字幕只能使用<code>srt</code>格式的（因为如果是特效字幕的话J1900就扛不住转码了）。<br>同时，由于找资源的速度过于快了，1年内nas的储存就即将告罄，为了未来3-5年左右能有充足的槽位进行扩展，同时也为了解决一下性能拉垮的问题，就踏上了本次捡垃圾之旅。</p><h1 id="购买人生的第二台NAS"><a href="#购买人生的第二台NAS" class="headerlink" title="购买人生的第二台NAS"></a>购买人生的第二台NAS</h1><h2 id="选购思路"><a href="#选购思路" class="headerlink" title="选购思路"></a>选购思路</h2><p>在挑选硬件的时候主要分为CPU性能、主板扩展性、储存扩展性、所使用操作系统这几个方向。<br>作为一个穷逼，长这么大到现在我连4k屏幕都没见过，所以对我而言CPU性能、主板扩展性是次要的，最主要的就是储存扩展性，也就是盘位的多少，其次是选择使用说明系统。<br>为了满足未来3-5年的储存需求，我就需要至少8盘位的机器保证有足够的盘位对储存进行扩容。<br>系统方面，不愿意继续使用黑群晖，所以选择了UNraid，至于为什么后面会说到</p><h2 id="确定硬件"><a href="#确定硬件" class="headerlink" title="确定硬件"></a>确定硬件</h2><p>为考虑的机器范围分为两个大方向：<code>DIY成品NAS</code>和<code>二手服务器</code><br>DIY成品NAS要满足我的需求价格其实就和二手服务器差不多，但同价位二手服务器比DIY成品NAS性能要高（虽然耗电量也高），所以果断选择了塔式服务器。从性能、扩展性、噪音各方面来说都很合适。<br>经过几天筛选，最后我买了一台DELL的塔式服务器，选定好了各种配件下单。以下是我选择并购入的物品清单</p><table><thead><tr><th>设备</th><th>数量</th><th>价格</th></tr></thead><tbody><tr><td>E5-2420v2</td><td>1</td><td>&#x2F;</td></tr><tr><td>8G DDR3 ECC 内存</td><td>2</td><td>&#x2F;</td></tr><tr><td>H310阵列卡</td><td>1</td><td>&#x2F;</td></tr><tr><td>服务器电源</td><td>1</td><td>&#x2F;</td></tr><tr><td>以上配置的T320</td><td>1</td><td>1800¥</td></tr><tr><td>3T 戴尔SAS服务器拆机盘</td><td>4</td><td>588¥</td></tr><tr><td>Unraid OS Plus 授权</td><td>1</td><td>89$（折合人民币570.35¥）</td></tr><tr><td>闪迪32G U盘</td><td>1</td><td>29.9¥</td></tr><tr><td>合计</td><td>&#x2F;</td><td>2988.25¥</td></tr></tbody></table><h2 id="意外的惊喜"><a href="#意外的惊喜" class="headerlink" title="意外的惊喜"></a>意外的惊喜</h2><p>在我拿到服务器之后，发现店家给我发了T420，也就是T320的双路版本！！！虽然不合适但还是不厚道的笑开了花 XD<br>实际我拿到的机器配置如下</p><table><thead><tr><th>设备</th><th>数量</th></tr></thead><tbody><tr><td>E5-2420v2</td><td>1</td></tr><tr><td>8G DDR3 ECC 内存</td><td>2</td></tr><tr><td>495W热插拔电源</td><td>2</td></tr><tr><td>H310阵列卡</td><td>1</td></tr></tbody></table><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://pic.imgdb.cn/item/61e943ea2ab3f51d9175dcaf.jpg"></div><div class="group-image-wrap"><img src="https://pic.imgdb.cn/item/61e943ea2ab3f51d9175dcb4.jpg"></div></div></div><p>可以说是血赚</p><h1 id="组装NAS"><a href="#组装NAS" class="headerlink" title="组装NAS"></a>组装NAS</h1><p>由于买的是成品，所谓硬件组装也就只是把硬盘塞好，插上UNraid的U盘</p><h2 id="U盘刷入UNraid"><a href="#U盘刷入UNraid" class="headerlink" title="U盘刷入UNraid"></a>U盘刷入UNraid</h2><p>UNraid的特性之一就是其系统是储存在U盘上的，U盘仅作为引导，开机后会将系统放入内存中运行。这一点上，由于服务器支持ECC内存的缘故，NAS运行起来会更加的可靠。<br>通过UNraid官网下载<a href="https://unraid.net/download">USB Flash Creator</a>,并按提示刷入U盘即可。<br><img src="https://pic.imgdb.cn/item/61e9462f2ab3f51d91781c27.png" alt="建议在刷入时就固定好IP"></p><h2 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h2><p>在把U盘和硬盘装好后，插电～开机～，进入bios设置，选择从U盘启动（UNraid不能使用UEFI启动，不然会有莫名其妙的问题）<br>当机器开机后就可以从浏览器登录web管理页面：<code>http://NAS-IP</code>,默认<code>root</code>用户无密码（登录后请设置好密码）</p><h3 id="设置好硬盘阵列"><a href="#设置好硬盘阵列" class="headerlink" title="设置好硬盘阵列"></a>设置好硬盘阵列</h3><p>我的设置思路是阵列中全为机械硬盘，并将SSD放在缓存池中，UNraid的缓存和群晖不太一样，其实缓存也是普通的硬盘，只是不受数据校验保护而已。之后会解释为什么。选择好硬盘后启动阵列。</p><h3 id="安装基本的插件"><a href="#安装基本的插件" class="headerlink" title="安装基本的插件"></a>安装基本的插件</h3><p>虽然UNraid于<code>6.9.2</code>版本已支持官方中文，但是需要通过插件安装。<br>找到导航栏中的<code>PLUGINS</code>，点击二级菜单中的<code>Install plugin</code>,并将以下链接复制到文本框中进行安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Squidly271&#x2F;community.applications&#x2F;master&#x2F;plugins&#x2F;community.applications.plg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><img src="https://pic.imgdb.cn/item/61e949262ab3f51d917ac6d0.png"><br>之后导航栏会多出一个<code>APPS</code>，点击后进入界面（由于众所周知的原因加载会比较慢），搜索并安装中文语言包，之后就可以切换为中文了</p><h3 id="设置共享文件夹"><a href="#设置共享文件夹" class="headerlink" title="设置共享文件夹"></a>设置共享文件夹</h3><p>我的NAS主要是围绕影音中心为目的而搭建的，所以这里以我的设置为例进行介绍。<br>UNraid的文件管理和群晖完全不一样，<strong>用户不需要关心自己的文件到底储存在哪个硬盘上，只需要注意由于文件的用途不同需要选择怎么样的储存策略</strong>，我的储存思路见下表</p><table><thead><tr><th>文件类型</th><th>特性</th><th>储存方案</th></tr></thead><tbody><tr><td>影音文件</td><td>量大，读取率相对低</td><td>不使用缓存盘，仅存储于阵列中，通过手工移动的方式将缓存盘或外部存储的数据写入共享文件夹</td></tr><tr><td>系统&#x2F;应用相关文件</td><td>体积小但需要经常读写</td><td>仅使用缓存，避免机械硬盘的经常读写</td></tr></tbody></table><p>由此简单的分为这两大类进行存储。</p><h4 id="我的设置"><a href="#我的设置" class="headerlink" title="我的设置"></a>我的设置</h4><p>新建一个媒体文件夹用于存放视频、音乐文件，设置参考下图<br><img src="https://pic.imgdb.cn/item/61e94d442ab3f51d917ea9d9.png"><br>将末认新建好的<code>appdata</code>、<code>domains</code>、<code>system</code>设置为仅缓存，即在这些文件夹中的数据仅会储存在缓存盘中。<br>新建一个<code>download</code>文件夹设为仅缓存，用于充当bt、pt或其他服务器的下载文件夹。</p><h4 id="SMB文件共享设置"><a href="#SMB文件共享设置" class="headerlink" title="SMB文件共享设置"></a>SMB文件共享设置</h4><p>如果你不希望公开共享文件夹，则需要在<code>user</code>设置中添加一个用户，并在共享文件夹设置中给予用户访问的权限！<strong>UNraid的root用户是不能用于登陆SMB服务的！</strong></p><h3 id="安装常用应用"><a href="#安装常用应用" class="headerlink" title="安装常用应用"></a>安装常用应用</h3><p>与群晖不同，绝大多数UNraid的应用都是通过docker安装的</p><h4 id="安装PLEX"><a href="#安装PLEX" class="headerlink" title="安装PLEX"></a>安装PLEX</h4><p><code>APPS</code>选项卡中搜索<code>Plex-Media-Server</code>，找到官方的那个点击安装。各项配置如下  </p><ul><li><code>Host Path 2</code>填写PLEX应用的数据储存位置，我选择储存在<code>appdata/</code>共享文件夹中，文件路径为<code>/mnt/user/appdata/</code></li><li><code>Host Path 3</code>填写媒体文件所在的文件夹，即前面创建的媒体文件夹，路径为<code>/mnt/user/media/</code></li><li><code>Key 1</code>需要填入神秘代码，请前往<a href="https://plex.tv/claim">PLEX官网</a>获取</li><li><code>Key 2</code>为容器的UID，默认填写<code>99</code></li><li><code>Key 3</code>为容器的GID，默认填写<code>100</code></li><li><code>Key 4</code>为容器版本，默认填写<code>latest</code></li></ul><p>填写好之后点击完成，等到容器上线即可</p><h4 id="FileBrowser文件管理安装"><a href="#FileBrowser文件管理安装" class="headerlink" title="FileBrowser文件管理安装"></a>FileBrowser文件管理安装</h4><p>由于UNraid作为NAS系统居然没有官方自带的web文件管理功能，所以这里需要自己安装一个。<br>安装的应用为荒野无灯大佬的魔改版（<a href="https://hub.docker.com/r/80x86/filebrowser">项目地址</a>），按照项目的说明安装即可</p><h4 id="安装aria2"><a href="#安装aria2" class="headerlink" title="安装aria2"></a>安装aria2</h4><p>这里使用P3TERX大佬的镜像，如果没有特殊需求，按照下面给出的配置进行安装即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker run -d \    --name aria2-pro \    --restart unless-stopped \    --log-opt max-size&#x3D;1m \    --network host \    -e PUID&#x3D;$UID \    -e PGID&#x3D;$GID \    -e RPC_SECRET&#x3D;此处填写RPC的密码 \    -e RPC_PORT&#x3D;6800 \    -e LISTEN_PORT&#x3D;6888 \    -v $PWD&#x2F;aria2-config:&#x2F;config \    -v $PWD&#x2F;aria2-downloads:&#x2F;downloads \    p3terx&#x2F;aria2-pro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="安装ariaNG"><a href="#安装ariaNG" class="headerlink" title="安装ariaNG"></a>安装ariaNG</h4><p>由于aria2-pro并不自带webUI，所以需要自己安装一个。设置参考下图<br><img src="https://pic.imgdb.cn/item/61e953762ab3f51d91850ae8.png"></p><h1 id="几天的使用体验"><a href="#几天的使用体验" class="headerlink" title="几天的使用体验"></a>几天的使用体验</h1><p>由于主要作为影音服务器使用，所以挺在意这颗U的性能如何的，刚开始我的要求仅是h264能正常使用即可，但没想到这颗U的性能超出预期，能解码H265 4K的影片！为我省了买显卡的钱。<br>同时，这台服务器有着极强的扩展性，巨量PCIe插槽，可以方便的扩展各种设备。比如未来可以加显卡搞Mac虚拟机；加装万兆网卡；加装阵列卡扩展存储等。几乎可以说，这台机器可以满足我未来5-10年的需求。<br>总之非常满意就是了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;h2 id=&quot;买NAS的缘由&quot;&gt;&lt;a href=&quot;#买NAS的缘由&quot; class=&quot;headerlink&quot; title=&quot;买NA</summary>
      
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="NAS" scheme="https://blog.xianyu.one/tags/NAS/"/>
    
    <category term="UNraid" scheme="https://blog.xianyu.one/tags/UNraid/"/>
    
    <category term="垃圾佬" scheme="https://blog.xianyu.one/tags/%E5%9E%83%E5%9C%BE%E4%BD%AC/"/>
    
    <category term="服务器" scheme="https://blog.xianyu.one/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>计网专业学习笔记——认识IPv4地址的发展史</title>
    <link href="https://blog.xianyu.one/2021/12/17/ip-address/"/>
    <id>https://blog.xianyu.one/2021/12/17/ip-address/</id>
    <published>2021-12-17T00:04:49.000Z</published>
    <updated>2025-02-11T12:56:25.426Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>属实无聊，就当考前复习。</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>初接触网络层的东西，相信不少人会有很多的疑惑，毕竟相较于物理层和数据链路层而言，网络层的东西会比较抽象。<br>在大学开设的这门课里我并没有遇到什么特别大的瓶颈和不理解的地方，这得益于多年来瞎折腾所学习到的知识。从身边遇到的问题入手，通过解决问题的方式学习知识，可以说是我本人最爱的学习方法。<br>所以，我想结合实例来讲解IPv4的相关知识，希望能对正在学习相关专业的学生以及爱好者有所帮助。  </p><h1 id="IPv4地址的结构"><a href="#IPv4地址的结构" class="headerlink" title="IPv4地址的结构"></a>IPv4地址的结构</h1><p>大家应该都知道，IPv4的地址写出来长这样：<code>192.168.1.1</code><br>我们为了阅读的方便，将十进制格式的IP地址用.分成了四个部分。<br>看，只是人类为了阅读方便而设置的。对于计算机而言IPv4地址长这样<code>11000000101010000000000100000001</code><br>其实就是二进制形式的地址。<br>我们也可以把二进制形式的地址拆成四份：<code>11000000</code> <code>10101000</code> <code>00000001</code> <code>00000001</code>  </p><table><thead><tr><th></th><th>第一段</th><th>第二段</th><th>第三段</th><th>第四段</th></tr></thead><tbody><tr><td>十进制格式</td><td>192</td><td>168</td><td>1</td><td>1</td></tr><tr><td>二进制格式</td><td>11000000</td><td>10101000</td><td>00000001</td><td>00000001</td></tr></tbody></table><p>简单看了一下格式，就可以继续往下说了。<br>别急，其他的诸如<code>子网掩码</code>、<code>网络号</code>、<code>主机号</code>的概念后面会慢慢讲。</p><h1 id="IPv4的发展历史"><a href="#IPv4的发展历史" class="headerlink" title="IPv4的发展历史"></a>IPv4的发展历史</h1><p>开始讲解IPv4地址，绕不开的话题就是要讲一讲IP发展的历史，看看IPv4是怎么样发展到现在这样的</p><h2 id="分类编址时代"><a href="#分类编址时代" class="headerlink" title="分类编址时代"></a>分类编址时代</h2><p>很久很久以前，IP地址被分成了五种地址类型，分别是<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code>五类。<br>他们的区分方式很简单，<strong>二进制形式的IP地址从左往右数，开头的几位数字的不同决定这个IP的分类。</strong><br>在判断属于一个IP属于哪一个类别时其实不需要把它变成二进制的形式，<strong>因为区分类别的位数只占4位，也就是说只要判断第一段的十进制数是在哪个区间即可知道这个IP的类别。</strong><br>可以参照以下表格进行判断：</p><table><thead><tr><th></th><th>A类地址</th><th>B类地址</th><th>C类地址</th><th>D类地址</th><th>E类地址</th></tr></thead><tbody><tr><td>二进制下的开头</td><td>0</td><td>10</td><td>110</td><td>1110</td><td>1111</td></tr><tr><td>二进制下的地址区间</td><td>00000001 - 01111110</td><td>10000000 - 10111111</td><td>11000000 - 11011111</td><td>11100000 - 11101111</td><td>11110000 - 11111111</td></tr><tr><td>十进制下的地址区间</td><td>1 - 126</td><td>128 - 191</td><td>192 - 223</td><td>224 - 239</td><td>240 - 255</td></tr></tbody></table><p><strong>注：A类地址中0和127两个段为保留地址，用于特殊目的。</strong>  </p><blockquote><p>对照这个表，就很容易分辨IP地址的分类了。以下给出几个IP地址，大家可以对照表格判断一下：</p><ul><li>192.168.66.12</li><li>11.43.192.30</li><li>11.43.192.30</li></ul></blockquote><h3 id="网络号-主机号"><a href="#网络号-主机号" class="headerlink" title="网络号 &amp; 主机号"></a>网络号 &amp; 主机号</h3><p>上文我们知道了，IP地址被划分成了五个类别<br>A、B、C类为单播地址，是我们平时接触最多，也是正在使用的地址。D是多播地址，E是保留地址。<br>对于A、B、C类的地址来说，它们除了开头不一样外，网络号和主机号的长度也是不一样的。<br>一个IPv4地址的二进制形式有32位，在分类编址时代，IP的组成形式为&lt;网络号&gt; + &lt;主机号&gt;。</p><ul><li>A类地址的网络号为前8位，后面24位为主机号。也就是十进制形式的 第一段 为网络号， 第二段+第三段+第四段 为主机号</li><li>B类地址的网络号为前16位，后面16位为主机号，也就是十进制形式的 第一段+第二段 为网络号， 第三段+第四段 为主机号</li><li>C类地址的网络号为前24位，后面8位为主机号，也就是十进制形式的 第一段+第二段+第三段 为网络号， 第四段 为主机号<br><strong>那么同为单播地址，为什么还要分成A、B、C三类呢？</strong><br>前面我们知道了，IP的组成形式为&lt;网络号&gt; + &lt;主机号&gt;，<strong>这当中的网络号代表的是这个IP所在的网段，而主机号则定义了这个IP在这一个网段中的编号。</strong><blockquote><p>打个比方：一个小区（整个IP地址库）里有很多栋居民楼（网络号），居民楼里很很多户人家（主机号）。<br>对于网络服务商来说，一般购买的都是一整个IP地址块，而不会购买单个IP地址。不同大小的运营商需求不同，需要的IP地址量不同，所以会需要选择购买合适数量的IP地址块。将单播地址分为三类的意义就在于，现在客户可以根据自己的需求选择IP地址块的大小了。<br>那么A、B、C类地址是如何做到区分地址块大小的呢？这就是&lt;网络号&gt; + &lt;主机号&gt;模式的作用了。</p></blockquote></li></ul><h4 id="计算地址块容量"><a href="#计算地址块容量" class="headerlink" title="计算地址块容量"></a>计算地址块容量</h4><blockquote><p>假设现在有八个空格，可以往里填入数字将其变为一个二进制的数，请问可以有多少个不同的数字？</p></blockquote><p>其实这个问题很容易算出来，方法很简单：<br>这里我们可以知道最高能写8位，那么能写出的数字量就是 $2^8&#x3D;256$ 个<br>同理，因为IPv4地址事实上是一串32位的二进制数字，所以就可以使用同样的方法计算出地址块的容量<br>从上面的内容中已经知道了，IP地址的组成形式为&lt;网络号&gt; + &lt;主机号&gt;，购买IP使用权的时候，<strong>购买的地址块其实是购买了&lt;网络号&gt;下包含的所有IP，就像网络服务商作为“包租婆”，购买了开发商的整栋楼（网络号）一样。</strong><br><strong>因为IP的长度固定，所以网络号越短，主机号越长，主机号越长，所包含的IP就越多！</strong></p><blockquote><p>再来简单做个题：黄先生购买了一个C类地址块，请问这相当于他买了多少个IP地址？<br>一个C类地址的前24位是网络号，后8位是主机号，主机号长度决定其拥有多少个IP。<br>所以黄先生拥有的IP地址块包含了 $2^8&#x3D;256$ 个地址。</p></blockquote><h2 id="划分子网时代"><a href="#划分子网时代" class="headerlink" title="划分子网时代"></a>划分子网时代</h2><blockquote><p>原先的分类编址时代，我们把实际用来分配使用的IP地址分成A、B、C类。也就是说网络服务商在购买IP地址的时候可以选择三种大小：</p><ul><li>A类地址块：包含  个地址</li><li>B类地址块：包含  个地址</li><li>C类地址块：包含  个地址<br>但这时候问题来了，比如我现在想购入4000个地址，这个数量大于C类的同时又远远小于B类所含的数量，想要买4000个地址要不就是买16个C类地址，或者出手极其阔绰直接购买B类地址块。<br>这就不可避免的造成了地址的浪费。</li></ul></blockquote><p>划分子网时代，将IP变成了&lt;网络号&gt; + &lt;子网号&gt; + &lt;主机号&gt;的形式，以满足这样的需求。<br>买4000个地址，就可以选择购买 B类地址中的一个子网 来实现最大程度的不浪费。</p><blockquote><p>B类地址网络号占了16位，此时我们只需要把主机号的一部分变为子网号，让主机号的位数所包含的IP地址块最接近4000个就可以最大程度避免浪费<br>通过计算可知：<br>$2^{12}&#x3D;4096$<br>所以，我们需要12位的主机号。在网络号固定为16位的B类地址中，将主机号部分的4位占用为子网号，再购买B类地址中的这个子网就可以了。</p><table><thead><tr><th>买包含4096个地址的B类子网</th><th>网络号</th><th>子网号</th><th>主机号</th></tr></thead><tbody><tr><td>二进制格式</td><td>10xx xxxx xxxx xxxx</td><td>xxxx</td><td>xxxx xxxx xxxx</td></tr><tr><td>对应位数</td><td>16位</td><td>4位</td><td>12位</td></tr></tbody></table></blockquote><h2 id="无分类编址时代"><a href="#无分类编址时代" class="headerlink" title="无分类编址时代"></a>无分类编址时代</h2><p>随着时间的推进，计算机网络变得越来越庞大，本就不富裕的IPv4地址需求越来越大，过去的划分子网方式已经不足以满足人们的需求了。<br>公网IP对于一般民众而言其实不会专门进行购买，而对于网络服务商来说，其购买的需求量就挺大的。也正因为此，C类地址仅有256个IP的超小容量极易不受人待见。对于互联网而言，急需更灵活的IP分配方式。1993年，无分类域间路由选择（Classless Inter-Domain Routing， CIDR）应运而生。<br>在划分子网时代，IP变成了&lt;网络号&gt; + &lt;子网号&gt; + &lt;主机号&gt;的形式，而到了无分类编址的时代，又把这个子网号去掉了，取而代之的是子网掩码的概念。<br>过去网络号长度是固定的，并且被固定了长度。而到了无分类编址时代，网络号的长度不固定了，可以根据需求指定任意长度的网络号。</p><h3 id="那如何指定网络号长度呢？"><a href="#那如何指定网络号长度呢？" class="headerlink" title="那如何指定网络号长度呢？"></a>那如何指定网络号长度呢？</h3><p>还是买4000个地址，按之前划分子网的办法，就是购买一个&lt;网络号16位&gt; + &lt;子网号4位&gt; + &lt;主机号12位&gt;的地址块。既然无分类编址去除了子网号，同时不限制网络号长度，那么直接把子网号的4位合并进网络号里就可以达到相同效果了<br>&lt;网络号20位&gt; + &lt;主机号12位&gt;<br>也就是说，我们买的地址块的网络号变成了20位。<br>因为无分类编址不依靠、也无法依靠网络类型来确定网络号长度，所以引入了子网掩码的概念。其实子网掩码的作用很简单，就是告诉我们网络号的长度。<br>上面我们买了一个网络号长度为20位的地址块，那么它的子网掩码长度就是20位，同时，子网掩码长度通过写1来表示，剩余位置以0填充</p><table><thead><tr><th>二进制IP地址</th><th>11001100 10001111 0011xxxx xxxxxxxx</th></tr></thead><tbody><tr><td>二进制子网掩码</td><td>11111111 11111111 11110000 00000000</td></tr></tbody></table><h3 id="这一串子网掩码看着像不像IP地址？"><a href="#这一串子网掩码看着像不像IP地址？" class="headerlink" title="这一串子网掩码看着像不像IP地址？"></a>这一串子网掩码看着像不像IP地址？</h3><p>对的，它也能变成十进制的形式：<code>255.255.240.0</code></p><h3 id="是不是还是很眼熟？"><a href="#是不是还是很眼熟？" class="headerlink" title="是不是还是很眼熟？"></a>是不是还是很眼熟？</h3><p>没错，在你的电脑&#x2F;手机的网络设置里就有它。<br>一般家庭的路由器会将局域网默认设置为<code>192.168.x.x/24</code>的形式，所以我们见到的地址比如<code>192.168.1.1/24</code>或<code>192.168.1.1</code> 子网掩码：<code>255.255.255.0</code>，对应的意思就是：IP地址为<code>192.168.1.1</code>，同时其子网掩码长度是<code>24</code>，或写作<code>255.255.255.0</code>。同一地址块下能够容纳的主机数为 $2^8&#x3D;256$ 台（其中包含两个特殊地址）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;属实无聊，就当考前复习。&lt;/p&gt;
&lt;h1 id=&quot;开篇&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="网络" scheme="https://blog.xianyu.one/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="IP地址" scheme="https://blog.xianyu.one/tags/IP%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>k8s折腾笔记——树莓派集群安装k3s</title>
    <link href="https://blog.xianyu.one/2021/11/16/Linux/tutorial/k8s-install/"/>
    <id>https://blog.xianyu.one/2021/11/16/Linux/tutorial/k8s-install/</id>
    <published>2021-11-16T01:37:07.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上个月和班主任聊天，知道了k8s（Kubernetes），瞬间来了折腾的兴趣。脑子一热买了三台树莓派4B。<br>由于其对初心者及其不友善的特点，断断续续拖了一个月，昨天刚弄好。<br>想到博客万年没更新了，来写一下。</p><blockquote><p>封面图来自：<a href="https://www.pixiv.net/artworks/76372910">画师JW —— 人总分不清梦境与现实。</a></p></blockquote><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>电脑一台(系统随意)</li><li>树莓派4B*3（我的是4GB的版本）</li><li>交换机</li><li>网线*4（树莓派连交换机3根，交换机连路由器1根）</li><li>SD卡*3（我是64GB的闪迪）</li><li><del>鞋盒*1</del></li></ul><p>此处树莓派供电我用的是绿联的三个快充头，以保证充足的供电。<br>有买亚克力的架子，组装后大概如下<br><img src="https://pic.imgdb.cn/item/619324ab2ab3f51d916aee7b.jpg"></p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li>各系统自带终端（用于ssh连接树莓派）</li><li>Debian-Pi-Aarch64 ★ 全新树莓派64位系统 <a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64">项目地址</a></li><li>balenaEtcher – 一个跨平台镜像烧录工具（Mac、Windows、Linux）<a href="https://www.balena.io/etcher/">官方网址</a></li><li>各种k8s相关的软件</li></ul><p><strong>注意：接下去的内容能够正常使用的前提是要有“良好的网络环境”，例如要能顺畅地pull到dockerHub上的镜像，否则将有极大概率无法完成安装！</strong></p><h1 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h1><p>这里使用的是<a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64">Debian-Pi-Aarch64 ★ 全新树莓派64位系统</a>的基础版无桌面镜像，烧录进SD卡后插电开机<br>默认账户：<code>pi</code>，默认密码：<code>raspberry</code><br>首先需要找到树莓派的IP地址，可以登录路由器后台查看。建议知道地址后将其固定下来，不固定也没事，之后会将其设置为静态IP。<br>以我的为例，我将三台树莓派分别命名为<code>rpi1</code>、<code>rpi2</code>、<code>rpi3</code>，其IP固定为如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">rpi1    192.168.6.91    #节点类型：Masterrpi2    192.168.6.92    #节点类型：noderpi3    192.168.6.93    #节点类型：node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>在k8s集群中，节点分为<code>Master</code>和<code>node</code>两种，<code>Master</code>节点是集群中负责调度任务等工作的控制面节点，<code>node</code>是工作节点。后续向集群中添加应用程序时，会由<code>Master</code>将任务指派给<code>node</code>。<br>接下去的内容默认是在root用户下执行，请使用<code>sudo -i</code>将用户变更为root并设置root用户密码</p><h2 id="更改主机名"><a href="#更改主机名" class="headerlink" title="更改主机名"></a>更改主机名</h2><p>首先要把三台主机的主机名更改回来（此处仅以rpi1为例）<br>ssh连接rpi1这里有两个文件内容要更改，第一个是<code>/etc/hosts</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将文件中的</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">127.0.0.1   raspberry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>更改为</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">127.0.0.1   rpi1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>第二个文件是<code>/etc/hostname</code><br>将内容改为<code>rpi1</code>即可。其他两台操作相同</p><h2 id="更改网络设置"><a href="#更改网络设置" class="headerlink" title="更改网络设置"></a>更改网络设置</h2><p>打开配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;network&#x2F;interfaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将文件内容修改为如下（此处依旧以rpi1为例，如果你的网段与我不同，请更改为自己的网段！请勿照抄）</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">auto eth0allow-htoplug eth0iface eth0 inet staticaddress 192.168.6.91netmask 255.255.255.0gateway 192.168.6.1dns-nameservers 114.114.114.114<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>接着将三台机器的IP地址添加到<code>/etc/hosts</code>文件中，并重启网络</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">sudo cat &gt;&gt; &#x2F;etc&#x2F;hosts &lt;&lt; EOF192.168.6.91 rpi1192.168.6.92 rpi2192.168.6.93 rpi3EOFservice networking restart <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="修改ssh设置"><a href="#修改ssh设置" class="headerlink" title="修改ssh设置"></a>修改ssh设置</h2><p>默认情况下，这个镜像是不允许直接使用root账号连接的，为了方便省事，需要允许直接使用root账号进行ssh连接</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>进入配置文件，将</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#PermitRootLogin prohibit-password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>修改为</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">PermitRootLogin yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>并重启服务</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="打开IPv4转发"><a href="#打开IPv4转发" class="headerlink" title="打开IPv4转发"></a>打开IPv4转发</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将文件中的这行注释去掉</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">net.ipv4.ip_forward &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">sudo &#x2F;usr&#x2F;sbin&#x2F;iptables -P FORWARD ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="关闭一些服务"><a href="#关闭一些服务" class="headerlink" title="关闭一些服务"></a>关闭一些服务</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">systemctl stop NetworkManager.servicesystemctl disable NetworkManager.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install -y net-tools lrzsz tree screen lsof tcpdump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="启用docker"><a href="#启用docker" class="headerlink" title="启用docker"></a>启用docker</h2><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">systemctl enable docker.service #开机自动启动Docker服务systemctl start docker.service #启动Docker服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="关闭Swap"><a href="#关闭Swap" class="headerlink" title="关闭Swap"></a>关闭Swap</h2><p>直接注释掉，简单粗暴</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">sed -ri &#39;s&#x2F;.swap.&#x2F;#&amp;&#x2F;&#39; &#x2F;etc&#x2F;fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>至此，系统配置已全部完成<br>重启一遍系统后，正式开始集群的部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">sudo reboot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h1 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h1><p>从这里开始，才算进入正片。由于k8s对于树莓派而言有点过于臃肿了（主要部署起来太折腾了），所以我使用的是<a href="https://k3s.io/">k3s</a>。</p><h2 id="k3s脚本安装"><a href="#k3s脚本安装" class="headerlink" title="k3s脚本安装"></a>k3s脚本安装</h2><p>对于没有网络问题的同学可以直接使用官方脚本进行安装，（请注意不要直接复制下面这行命令，我们需要加上相关参数执行！）</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">curl -sfL https:&#x2F;&#x2F;get.k3s.io | sh -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>同时，如果网络有问题，可以参考<a href="https://docs.rancher.cn/docs/k3s/installation/install-options/_index/">官方文档</a>使用国内镜像。<br>此处不直接使用这个脚本，而是预先添加参数，分别在<code>Master</code>和<code>node</code>执行</p><h3 id="Master机执行"><a href="#Master机执行" class="headerlink" title="Master机执行"></a>Master机执行</h3><p><code>Master</code>机脚本如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">curl -sfL https:&#x2F;&#x2F;get.k3s.io |  K3S_NODE_NAME&#x3D;rpi1 sh -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果网络有问题请在命令中添加参数<code>INSTALL_K3S_MIRROR=cn</code>，以使用国内镜像<br>此处<code>K3S_NODE_NAME</code>为指定此机器在集群中的名字，为方便识别这里设置为和主机名<code>rpi1</code>一样的名字。<br>等待执行完后，需要获取<code>Token</code>，给后续添加进集群的机器使用。请保存好这个<code>Token</code>，接下去要用到。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;var&#x2F;lib&#x2F;rancher&#x2F;k3s&#x2F;server&#x2F;node-token #获取rpi1的Token<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="node机执行"><a href="#node机执行" class="headerlink" title="node机执行"></a>node机执行</h3><p>前面我们在<code>Master</code>机获取到了<code>Token</code>，假设它为</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">K107dfc82a8d9453e538b26dd3250757827356a276ae509c3158b60ec3238e7929f::server:bac90b26fc5t6b2c76a8ee1bc22291cc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>那么在<code>rpi2</code>、<code>rpi3</code>这两个<code>node</code>节点上的执行命令为</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">curl -sfL https:&#x2F;&#x2F;get.k3s.io |  K3S_NODE_NAME&#x3D;rpi2 K3S_URL&#x3D;https:&#x2F;&#x2F;192.168.6.91:6443 K3S_TOKEN&#x3D;K107dfc82a8d9453e538b26dd3250757827356a276ae509c3158b60ec3238e7929f::server:bac90b26fc5t6b2c76a8ee1bc22291cc sh - #这个命令在rpi2上执行curl -sfL https:&#x2F;&#x2F;get.k3s.io |  K3S_NODE_NAME&#x3D;rpi3 K3S_URL&#x3D;https:&#x2F;&#x2F;192.168.6.91:6443 K3S_TOKEN&#x3D;K107dfc82a8d9453e538b26dd3250757827356a276ae509c3158b60ec3238e7929f::server:bac90b26fc5t6b2c76a8ee1bc22291cc sh - #这个命令在rpi3上执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>参数<code>K3S_URL</code>为<code>Master</code>结点（即这里的<code>rpi1</code>结点），参数<code>K3S_TOKEN</code>填入上面的<code>Token</code><br>如果网络有问题请在命令中添加参数<code>INSTALL_K3S_MIRROR=cn</code>，以使用国内镜像</p><h3 id="回到Master机查看集群状态"><a href="#回到Master机查看集群状态" class="headerlink" title="回到Master机查看集群状态"></a>回到Master机查看集群状态</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果没有问题将会看到如下显示，三个结点都已在集群中，并已<code>ready</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">NAME   STATUS   ROLES                  AGE   VERSIONrpi2   Ready    &lt;none&gt;                 32h   v1.21.5+k3s2rpi3   Ready    &lt;none&gt;                 32h   v1.21.5+k3s2rpi1   Ready    control-plane,master   32h   v1.21.5+k3s2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用以下命令查看<code>pods</code>是否已正常运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">kubectl get pods -A <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>基本如下所示就是正常的</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">NAMESPACE              NAME                                         READY   STATUS      RESTARTS   AGEkube-system            local-path-provisioner-5ff76fc89d-pd7rd      1&#x2F;1     Running     0          32hkube-system            coredns-7448499f4d-dlwqx                     1&#x2F;1     Running     0          32hkube-system            helm-install-traefik-crd-lpgwj               0&#x2F;1     Completed   0          32hkube-system            helm-install-traefik-gqrr9                   0&#x2F;1     Completed   1          32hkube-system            svclb-traefik-rrwqk                          2&#x2F;2     Running     0          32hkube-system            traefik-97b44b794-h2rqp                      1&#x2F;1     Running     0          32hkube-system            svclb-traefik-49gc9                          2&#x2F;2     Running     0          32hkube-system            svclb-traefik-nltmk                          2&#x2F;2     Running     0          32h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>至此k3s的安装也就告一段落了。</p><h1 id="安装一些管理应用"><a href="#安装一些管理应用" class="headerlink" title="安装一些管理应用"></a>安装一些管理应用</h1><p>到目前为止，<code>k3s</code>还只能在命令行使用，由于其复杂程度非常不利于初心者的使用，对于学习来说，快速开始使用是挺重要的，这里介绍<code>Kubernetes Dashboard</code>和<code>Kuboard</code>的部署。对于k8s集群来说，部署任务只需要在<code>Master</code>机上执行即可，<code>Master</code>节点会向<code>node</code>节点指派任务。所以以下操作均是在<code>Master</code>机上执行的（在我的集群中是<code>rpi1</code>）</p><h2 id="安装Kubernetes-Dashboard"><a href="#安装Kubernetes-Dashboard" class="headerlink" title="安装Kubernetes Dashboard"></a>安装Kubernetes Dashboard</h2><p>执行以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.2.0&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>执行完后需要等待一段时间，集群拉取镜像和指派任务需要一点时间<br>可以通过以下命令查看部署情况</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">watch kubectl get pods -n kuboard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果为<code>ready</code>则说明已经部署完成了</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">NAME                                         READY   STATUS    RESTARTS   AGEkubernetes-dashboard-78c79f97b4-v9565        1&#x2F;1     Running   0          32hdashboard-metrics-scraper-856586f554-z8nz5   1&#x2F;1     Running   0          32h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="使Kubernetes-Dashboard在集群外部可用"><a href="#使Kubernetes-Dashboard在集群外部可用" class="headerlink" title="使Kubernetes Dashboard在集群外部可用"></a>使Kubernetes Dashboard在集群外部可用</h3><p>在部署完成后，在<code>Master</code>机上执行<code>kubectl proxy</code>可以使其在<code>Master</code>机上访问（<a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/%EF%BC%89%EF%BC%8C%E4%BD%86%E8%BF%99%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E6%9D%A5%E8%AF%B4%E6%98%AF%E4%B8%8D%E5%A4%9F%E7%9A%84%E3%80%82%E5%A4%A7%E5%85%AC%E5%8F%B8%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%B8%A6%E6%A1%8C%E9%9D%A2%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%9C%A8%E6%9C%BA%E6%88%BF%E4%B8%AD%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%60Master%60%E6%9C%BA%EF%BC%8C%E4%BD%86%E5%B9%B3%E7%A9%B7%E5%A6%82%E6%88%91%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E6%97%A0%E6%A1%8C%E9%9D%A2%E9%95%9C%E5%83%8F%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BB%84%E9%9B%86%E7%BE%A4%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E8%87%B3%E5%B0%91%E8%A6%81%E8%AE%A9%E5%AE%83%E6%9A%B4%E9%9C%B2%E5%9C%A8%E9%9B%86%E7%BE%A4%E5%A4%96%EF%BC%8C%E8%87%B3%E5%B0%91%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E3%80%82">地址</a>） ，但这对于我们来说是不够的。大公司可以用带桌面的系统，在机房中直接操作<code>Master</code>机，但平穷如我只能使用无桌面镜像的树莓派组集群，所以我们至少要让它暴露在集群外，至少在局域网下可以使用。<br>此时就需要对其配置进行修改。执行以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">kubectl patch svc kubernetes-dashboard -n kubernetes-dashboard -p &#39;&#123;&quot;spec&quot;:&#123;&quot;type&quot;:&quot;NodePort&quot;,&quot;ports&quot;:[&#123;&quot;port&quot;:443,&quot;targetPort&quot;:8443,&quot;nodePort&quot;:30443&#125;]&#125;&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这个命令的意义在于让<code>Kubernetes Dashboard</code>的端口暴露在<code>nodePort</code>（节点端口）<code>30443</code>上，是我们可以通过访问<code>rpi1</code>（<code>192.168.6.91</code>）的<code>30443</code>端口，执行完后，就可以通过访问 <a href="https://192.168.6.91:30443/">https://192.168.6.91:30443</a> 使用<code>Kubernetes Dashboard</code>了。<br><br><br>但是！<br>但是由于目前集群使用的是自签名的ssl证书，对于浏览器而言是不受信任的，还无法直接访问。对于Firefox浏览器而言可以配置例外情况进行访问，而Google Chrome呢，它没给我们选项怎么办？<br>不用怕，其实Google Chrome有留“秘籍”！<br>点击以下页面的空白处，然后在键盘上敲thisisunsafe并回车就可以访问！非常有Google的风格。<br><br></p><h3 id="登录使用Kubernetes-Dashboard"><a href="#登录使用Kubernetes-Dashboard" class="headerlink" title="登录使用Kubernetes Dashboard"></a>登录使用Kubernetes Dashboard</h3><p><code>Kubernetes Dashboard</code>提供了两种登录方式，一种是<code>Token</code>，另一种是<code>Kubeconfig</code>。这里我只说<code>Token</code>的方法。<br>执行以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;var&#x2F;lib&#x2F;rancher&#x2F;k3s&#x2F;server&#x2F;manifests&#x2F; #进入&#x2F;var&#x2F;lib&#x2F;rancher&#x2F;k3s&#x2F;server&#x2F;manifests&#x2F;目录#创建并向dashboard-adminuser.yaml写入内容cat &gt; dashboard-adminuser.yaml &lt;&lt; EOFapiVersion: v1kind: ServiceAccountmetadata:  name: admin-user  namespace: kubernetes-dashboard---apiVersion: rbac.authorization.k8s.io&#x2F;v1kind: ClusterRoleBindingmetadata:  name: admin-userroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:- kind: ServiceAccount  name: admin-user  namespace: kubernetes-dashboard  EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后通过以下命令获取到<code>Token</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;&#123;print $1&#125;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>将输出的<code>Token</code>填写在网页中即可。接下去就可以开始使用了</p><h2 id="安装Kuboard"><a href="#安装Kuboard" class="headerlink" title="安装Kuboard"></a>安装Kuboard</h2><p>看了<code>Kubernetes Dashboard</code>的安装以及进入<code>Kubernetes Dashboard</code>的页面后是不是感觉还是很麻烦？是不是觉得看到一大堆各种各样的洋文无从下手？没错，我也这么觉得。所以这里我们安装<code>Kuboard</code>方<code>便我们之后的使用。 不过这里就不在k8s中部署了，而是直接在</code>rpi1<code>上使用</code>docker<code>部署。这里只介绍</code>docker&#96;上的部署，其他的方式请参阅<a href="https://kuboard.cn/install/v3/install.html#kuboard-v3-x-%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">官方文档</a>。</p><h3 id="部署Kuboard镜像"><a href="#部署Kuboard镜像" class="headerlink" title="部署Kuboard镜像"></a>部署Kuboard镜像</h3><p>在rpi1上执行以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">docker run -d \  --restart&#x3D;unless-stopped \  --name&#x3D;kuboard \  -p 60080:80&#x2F;tcp \  -p 60081:10081&#x2F;tcp \  -e KUBOARD_ENDPOINT&#x3D;&quot;http:&#x2F;&#x2F;192.168.6.91:60080&quot; \  -e KUBOARD_AGENT_SERVER_TCP_PORT&#x3D;&quot;60081&quot; \  -v &#x2F;root&#x2F;kuboard-data:&#x2F;data \  eipwork&#x2F;kuboard:v3.3.0.0-arm64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>参数<code>KUBOARD_ENDPOINT</code>中的地址为之后Web界面的访问地址，命令中的各部分可根据实际需求自由替换，详情参阅官方文档<br>部署完成之后直接访问 <a href="http://192.168.6.91:60080/">http://192.168.6.91:60080</a> 即可开始使用。比官方的<code>Kubernetes Dashboard</code>属实方便多了。<br><code>Kuboard</code>的默认用户名：<code>admin</code>，默认密码：<code>Kuboard123</code><br>现在开始，你也可以使用反向代理、内网穿透、端口映射等手段让管理界面在公网上可用。</p><h3 id="添加集群"><a href="#添加集群" class="headerlink" title="添加集群"></a>添加集群</h3><p>当我们完成了上面的设置，并不代表我们可以直接使用<code>Kuboard</code>对集群进行管理，还需要在设置中添加集群。<br><code>Kuboard</code>提供了两种方法<br><img src="https://pic.imgdb.cn/item/619399f72ab3f51d91a2697b.png"><br>这里我们选择<code>agent</code>的方式<br>填写名称和描述，其他默认，直接点确定，然后根据提示在<code>Master</code>机执行命令即可，基本无脑点确定就行，非常方便。<br>集群导入成功后即可开始使用<br><img src="https://pic.imgdb.cn/item/61939af62ab3f51d91a2f076.png"></p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>为了玩这个真的投入了不少时间和金钱，确实折腾人。目前还没搞懂k8s的很多概念，有非常多不理解的地方，对于任务的部署其实还完全不了解，回头理解了再发新的文章介绍。<del>估计要明年发了</del></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/384328373">Raspberry Pi4b 集群基于Raspbian Buster搭建K3S集群</a></li><li><a href="https://zhuanlan.zhihu.com/p/390805379">手把手教大家使用树莓派4B搭建K8s集群</a></li><li><a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64/blob/master/README_zh.md">Debian-Pi-Aarch64 ★ 全新树莓派64位系统 2.0正式版 - 说明文档</a></li><li><a href="https://docs.rancher.cn/docs/k3s/installation/install-options/_index/">k3s —— 安装选项介绍</a></li><li><a href="https://kuboard.cn/install/v3/install.html">Kuboard —— 安装Kubernetes 多集群管理工具 - Kuboard v3</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;上个月和班主任聊天，知道了k8s（Kubernetes），瞬间来了折腾的兴趣。脑子一热买了三台树莓派4B。&lt;br&gt;由于其对初</summary>
      
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="k8s" scheme="https://blog.xianyu.one/tags/k8s/"/>
    
    <category term="Kubernetes" scheme="https://blog.xianyu.one/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>OnePlus 8T 刷机笔记</title>
    <link href="https://blog.xianyu.one/2021/10/20/Android/onepe/"/>
    <id>https://blog.xianyu.one/2021/10/20/Android/onepe/</id>
    <published>2021-10-19T22:08:41.000Z</published>
    <updated>2025-02-11T12:56:25.425Z</updated>
    
    <content type="html"><![CDATA[<p>很早就刷了，只不过一直懒的写。</p><span id="more"></span><h1 id="所需设备"><a href="#所需设备" class="headerlink" title="所需设备"></a>所需设备</h1><ul><li>电脑一台（配置好adb）</li><li>数据线一根</li><li>手机一只</li><li>人脑一个</li></ul><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="刷入氧OS"><a href="#刷入氧OS" class="headerlink" title="刷入氧OS"></a>刷入氧OS</h2><p><a href="https://www.oneplusbbs.com/thread-5689136-1.html">此处</a>下载9008救砖包，请注意：不要省略刷欧版的这一步！按照帖子用救砖包刷入欧版即可。</p><h2 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h2><p>进入设置，找到版本号狂点，开启开发者选项。<br>在开发者选项中打开<code>oem解锁</code>和<code>usb调试</code><br>手机连电脑后显示usb调试时选择<code>全部允许</code><br>电脑命令行下输入</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">adb reboot fastboot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>进入<code>fastboot</code>模式，开始解锁<code>oem</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">fastboot oem unlock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>此时需要在手机上操作，按手机音量键将光标以至<code>unlock</code></p><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>从<a href="https://download.pixelexperience.org/kebab">官网</a>下载PE ROM<br>使用<code>payload_dumper</code>解包<br>解包后文件夹<code>output</code>中的内容物就是我们需要用到的东西</p><h2 id="刷入"><a href="#刷入" class="headerlink" title="刷入"></a>刷入</h2><p>一样需要重新打开开发者模式，打开USB调试<br>然后按以下顺序刷入即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">adb reboot bootloaderfastboot flash recovery D:\ payload_dumper-win64\ payload_output\recovery.imgfastboot flash boot D:\ payload_dumper-win64\ payload_output\boot.imgfastboot flash dtbo D:\ payload_dumper-win64\ payload_output\dtbo.imgfastboot flash vbmeta D:\ payload_dumper-win64\ payload_output\vbmeta.imgfastboot flash vbmeta_system D:\ payload_dumper-win64\payload_output\vbmeta_system.imgfastboot reboot fastbootfastboot flash system D:\ payload_dumper-win64\ payload_output\system.imgfastboot flash product D:\ payload_dumper-win64\ payload_output\product.imgfastboot flash system_ext D:\ payload_dumper-win64\ payload_output\system_ext.imgfastboot reboot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;很早就刷了，只不过一直懒的写。&lt;/p&gt;</summary>
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="刷机" scheme="https://blog.xianyu.one/tags/%E5%88%B7%E6%9C%BA/"/>
    
    <category term="安卓" scheme="https://blog.xianyu.one/tags/%E5%AE%89%E5%8D%93/"/>
    
    <category term="PEROM" scheme="https://blog.xianyu.one/tags/PEROM/"/>
    
    <category term="PixelExperience" scheme="https://blog.xianyu.one/tags/PixelExperience/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装gcc的小教程</title>
    <link href="https://blog.xianyu.one/2021/10/08/win-inst-gcc/"/>
    <id>https://blog.xianyu.one/2021/10/08/win-inst-gcc/</id>
    <published>2021-10-07T20:23:26.000Z</published>
    <updated>2025-02-11T12:56:25.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>正式开学了，第一天直入主题，学c。<br>学校电脑很垃圾<br>用的软件更垃圾<br>总之就是很难用</p><p>本文献给我的同学们。</p><p>旨在帮助不想使用学校电脑的同学们使用自己的笔电更好地学习c语言</p><span id="more"></span><h1 id="所需物品"><a href="#所需物品" class="headerlink" title="所需物品"></a>所需物品</h1><ul><li>Windows系统的电脑一台</li><li>一个良好的网络环境（最好能正常访问海外网站）</li></ul><h1 id="实做过程"><a href="#实做过程" class="headerlink" title="实做过程"></a>实做过程</h1><p>强烈推荐使用<a href="https://code.visualstudio.com/">VScode</a>写代码！！！</p><h2 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h2><p>Linux有自带的GNU，Mac自带clang，都可以不需要额外操作就正常使用gcc对代码进行编译<br>而Windows没有！没有！！！<br><img src="https://pic.imgdb.cn/item/616001712ab3f51d91b8c979.jpg"><br>所以这时候我们就需要安装MinGW来解决这个问题。</p><h3 id="下载MinGW"><a href="#下载MinGW" class="headerlink" title="下载MinGW"></a>下载MinGW</h3><p>网好的同学可以直接在<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">下载</a>。进入网页后向下找到x86_64-posix-seh点击即可下载。</p><h3 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h3><p>下载后会得到名字为<code>x</code>86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z<code>的压缩包。 默认情况下Windows是不能解压的，这里可以下载[Bandizip](https://www.bandisoft.com/)来解压缩。 解压位置随意，但记得记下来之后要用。 比如文件夹解压到了C盘根目录，那么文件夹路径即为</code>C:\mingw64<code> 文件夹路径加上bin后就是之后要用的文件夹路径（</code>C:\mingw64\bin&#96;)</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>右键点击<code>此电脑</code>，在侧边栏找到<code>高级设置</code><br>在高级设置的界面里点击<code>环境变量</code>的选项，此时会看到<code>PATH</code>变量<br>点击<code>PATH</code>，将文件夹路径(<code>C:\mingw64\bin</code>)添加到里面即可</p><h3 id="如何验证是否成功安装"><a href="#如何验证是否成功安装" class="headerlink" title="如何验证是否成功安装"></a>如何验证是否成功安装</h3><p>在Windows菜单栏搜索cmd，打开命令行操作界面输入以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">gcc -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如果跳出一大堆看不懂的英文或者中文就说明安装成功了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h1&gt;&lt;p&gt;正式开学了，第一天直入主题，学c。&lt;br&gt;学校电脑很垃圾&lt;br&gt;用的软件更垃圾&lt;br&gt;总之就是很难用&lt;/p&gt;
&lt;p&gt;本文献给我的同学们。&lt;/p&gt;
&lt;p&gt;旨在帮助不想使用学校电脑的同学们使用自己的笔电更好地学习c语言&lt;/p&gt;</summary>
    
    
    
    
    <category term="教程" scheme="https://blog.xianyu.one/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Windows" scheme="https://blog.xianyu.one/tags/Windows/"/>
    
    <category term="开发" scheme="https://blog.xianyu.one/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="c语言" scheme="https://blog.xianyu.one/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
